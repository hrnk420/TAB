<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>統合TAB変換ツール</title>
    <link rel="stylesheet" href="./core.css" />
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: Consolas, monospace;
            margin: 20px;
            background-color: #2e2e2e;
            color: #f7f7f7;
        }
        h1 {
            color: #007acc;
            text-align: center;
            margin-bottom: 20px;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        #lang-switcher button {
            background: none;
            border: 1px solid #007acc;
            color: #007acc;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            margin-left: 5px;
        }
        #lang-switcher button.active {
            background: #007acc;
            color: white;
        }
        textarea, pre {
            width: 100%;
            min-height: 160px;
            font-family: Consolas, monospace;
            font-size: 14px;
            margin-bottom: 12px;
            padding: 10px;
            background-color: #3e3e3e;
            color: #f7f7f7;
            border: 1px solid #007acc;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .button-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 12px;
            font-size: 16px;
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
        }
        button:hover {
            background-color: #005a9e;
        }
        .message {
            margin-top: 20px;
            font-weight: bold;
            color: #4CAF50;
        }
        py-terminal,
        py-repl,
        .py-terminal,
        .py-repl,
        .py-error,
        .pyscript {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        /* tab_converter.html からの追加CSS */
        .tuning-options {
            margin-bottom: 15px;
            border: 1px solid #007acc;
            padding: 10px;
            border-radius: 5px;
            background-color: #3e3e3e;
        }
        .tuning-options b {
            color: #f7f7f7;
        }
        .tuning-options .btn-group .btn {
            background-color: #555;
            color: #f7f7f7;
            border-color: #007acc;
        }
        .tuning-options .btn-group .btn.active {
            background-color: #007acc;
            color: white;
        }
        /* UI調整のための新しいCSS */
        #custom-tuning-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around; /* Adjust as needed */
            gap: 10px; /* Space between string groups */
            margin-top: 10px;
        }
        .tuning-string-group {
            display: flex;
            flex-direction: row; /* Change to row for horizontal alignment */
            align-items: center; /* Vertically center items */
            justify-content: space-between; /* Distribute space between items */
            flex: 1; /* Make them grow equally */
            min-width: 200px; /* Ensure a minimum width to prevent squishing */
            max-width: 24%; /* Allow wrapping, roughly 4 per row */
            padding: 5px 10px; /* Adjust padding */
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #4a4a4a;
            box-sizing: border-box; /* Include padding and border in the element's total width */
        }
        .tuning-string-group .string-label {
            font-weight: bold;
            margin-right: 10px; /* Space between label and selects */
            color: #f7f7f7;
            white-space: nowrap; /* Prevent label from wrapping */
        }
        .tuning-string-group select {
            width: 60px; /* Adjust width for selects */
            margin-bottom: 0; /* Remove bottom margin */
            margin-left: 5px; /* Space between selects */
            background-color: #5e5e5e;
            color: #f7f7f7;
            border-color: #007acc;
        }
        .fret-note.playing-fret {
            background-color: yellow; /* Or any other highlighting color */
            color: #2e2e2e; /* Change text color for better visibility */
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="header-container">
    <h1>🎸 4弦 → 5弦TAB変換ツール</h1>
    <div id="lang-switcher">
        <button id="lang-ja">日本語</button>
        <button id="lang-en">English</button>
    </div>
</div>
<p data-lang-key="app_description">4弦ベース用のTAB譜を、5弦ベース用に最適化されたTAB譜に変換します。</p>
<p data-lang-key="instructions">4弦TAB (コメント行含む) を入力してください:</p>

<div class="conversion-options">
    <label>
        <input type="radio" name="conversion_mode" value="standard" checked>
        <span data-lang-key="conversion_mode_standard">標準5弦変換</span>
    </label>
    <label>
        <input type="radio" name="conversion_mode" value="b_string_optimized">
        <span data-lang-key="conversion_mode_b_string_optimized">B弦優先5弦変換</span>
    </label>
</div>

<div class="tuning-options">
    <b data-lang-key="tuning_options_title">チューニング補正オプション</b>
    
    <div class="btn-group btn-group-sm my-2" role="group" id="tuning-presets">
        <button type="button" class="btn btn-outline-secondary" data-tuning="standard" data-lang-key="tuning_standard">通常</button>
        <button type="button" class="btn btn-outline-secondary" data-tuning="half_down" data-lang-key="tuning_half_down">半音下げ</button>
        <button type="button" class="btn btn-outline-secondary" data-tuning="drop_d" data-lang-key="tuning_drop_d">ドロップD</button>
    </div>

    <div id="custom-tuning-area"></div>
</div>

<textarea id="input_tab" data-lang-key-placeholder="placeholder_text" placeholder="ここに4弦TAB（G|... D|... A|... E|...）を貼り付けてください"></textarea>

<div class="bpm-container" style="margin-bottom: 10px; text-align: right;">
    <label for="bpm_input" style="color: #f7f7f7;">BPM: </label>
    <input type="number" id="bpm_input" value="120" min="40" max="300" style="width: 60px; background-color: #3e3e3e; color: #f7f7f7; border: 1px solid #007acc; padding: 5px; border-radius: 5px;">
</div>

<div class="button-container">
    <button id="play_input_btn" data-lang-key="btn_play_input">▶ 再生 (入力)</button>
    <button id="get_template_btn" data-lang-key="btn_get_template">テンプレートDL (.txt)</button>
    <button id="format_check_btn" data-lang-key="btn_format_check">フォーマットチェック</button>
    <button id="convert_btn" data-lang-key="btn_convert">5弦TABに変換</button>
    <button id="play_output_btn" data-lang-key="btn_play_output">▶ 再生 (出力)</button>
    <button id="export_midi_btn" data-lang-key="btn_export_midi">MIDIエクスポート</button>
    <button id="download_btn" data-lang-key="btn_download_txt">変換結果DL (.txt)</button>
    <button id="download_pdf_btn">変換結果DL (.pdf)</button>
</div>

<p class="message" id="status_message"></p>
<pre id="output_tab"></pre>

<py-script>
from js import document, Blob, URL
from pyodide.ffi import create_proxy
import json

LANGUAGES = {
    'ja': {
        'app_title': "🎸 4弦 → 5弦TAB変換ツール",
        'app_description': "4弦ベース用のTAB譜を、5弦ベース用に最適化されたTAB譜に変換します。",
        'instructions': "4弦TAB (コメント行含む) を入力してください:",
        'placeholder_text': "ここに4弦TAB（G|... D|... A|... E|...）を貼り付けてください",
        'btn_get_template': "テンプレートDL (.txt)",
        'btn_format_check': "フォーマットチェック",
        'btn_convert': "5弦TABに変換",
        'btn_download_txt': "変換結果DL (.txt)",
        'status_template_success': "テンプレートが入力欄に表示されました。⬆️",
        'status_format_ok': "フォーマットチェック: OK ✅",
        'status_format_error': "フォーマットエラー: {error} ❌",
        'status_convert_success': "変換成功！下の欄に5弦TABが表示されました。🎉",
        'status_convert_error': "変換中にエラー発生: {error}",
        'status_download_success': "変換結果をダウンロードしました。",
        'status_download_empty': "ダウンロードする変換結果がありません。先に変換してください。",
        'template_download_success': "テンプレートファイルをダウンロードしました。",
        'conversion_mode_standard': "標準5弦変換",
        'conversion_mode_b_string_optimized': "B弦優先5弦変換",
        'tuning_options_title': "チューニング補正オプション",
        'tuning_standard': "通常",
        'tuning_half_down': "半音下げ",
        'tuning_drop_d': "ドロップD",
        'btn_play_input': "▶ 再生 (入力)",
        'btn_play_output': "▶ 再生 (出力)",
        'btn_export_midi': "MIDIエクスポート",
        'status_no_notes_to_play': "再生する音符がありません。",
        'status_no_notes_to_export': "エクスポートする音符がありません。",
        'status_midi_exported': "MIDIファイルをエクスポートしました。"
    },
    'en': {
        'app_title': "🎸 4-String to 5-String TAB Converter",
        'app_description': "Convert 4-string bass TABs to optimized 5-string TABs.",
        'instructions': "Enter 4-string TAB (including comment lines):",
        'placeholder_text': "Paste your 4-string TAB here (G|... D|... A|... E|...)",
        'btn_get_template': "Download Template (.txt)",
        'btn_format_check': "Check Format",
        'btn_convert': "Convert to 5-String TAB",
        'btn_download_txt': "Download Result (.txt)",
        'status_template_success': "Template has been loaded into the input area. ⬆️",
        'status_format_ok': "Format Check: OK ✅",
        'status_format_error': "Format Error: {error}",
        'status_convert_success': "Conversion successful! 5-string TAB is shown below. 🎉",
        'status_convert_error': "Error during conversion: {error}",
        'status_download_success': "Downloaded the conversion result.",
        'status_download_empty': "No result to download. Please convert first.",
        'template_download_success': "Template file downloaded.",
        'conversion_mode_standard': "Standard 5-string Conversion",
        'conversion_mode_b_string_optimized': "B-string Optimized 5-string Conversion",
        'tuning_options_title': "Tuning Correction Options",
        'tuning_standard': "Standard",
        'tuning_half_down': "Half-step down",
        'tuning_drop_d': "Drop D",
        'btn_play_input': "▶ Play (Input)",
        'btn_play_output': "▶ Play (Output)",
        'btn_export_midi': "Export MIDI",
        'status_no_notes_to_play': "No notes to play.",
        'status_no_notes_to_export': "No notes to export.",
        'status_midi_exported': "MIDI file exported."
    }
}
CURRENT_LANG = 'ja'
CONVERTED_NOTES_DATA = None
SYMBOLS = ['h', 'p', 'b', '^', 'v', '~', 'x']
string_open_midi_5str = [59, 64, 69, 74, 79]
display_order = [4, 3, 2, 1, 0]
NOTE_MAP = {'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11}

def note_to_midi(note_name, octave):
    note_val = NOTE_MAP.get(note_name.upper())
    if note_val is None: return 0
    return note_val + (octave + 1) * 12

def get_note_name_from_midi(midi_note):
    if midi_note is None: return None
    note_index = midi_note % 12
    for name, index in NOTE_MAP.items():
        if index == note_index:
            return name
    return None

def set_language(lang):
    global CURRENT_LANG
    CURRENT_LANG = lang
    translations = LANGUAGES[lang]
    document.querySelector("h1").textContent = translations['app_title']
    for element in document.querySelectorAll("[data-lang-key]"):
        key = element.getAttribute("data-lang-key")
        if key in translations:
            child_span = element.querySelector("span")
            if child_span:
                child_span.textContent = translations[key]
            else:
                element.textContent = translations[key]
    for element in document.querySelectorAll("[data-lang-key-placeholder]"):
        key = element.getAttribute("data-lang-key-placeholder")
        if key in translations:
            element.setAttribute("placeholder", translations[key])
    document.getElementById("lang-ja").classList.toggle('active', lang == 'ja')
    document.getElementById("lang-en").classList.toggle('active', lang == 'en')

def extract_fret_and_symbol(cell_content, string_name=""):
    if not cell_content: raise ValueError(f"{string_name}弦: 空のセルです。")
    if all(c == '-' for c in cell_content): return None, None
    start_idx = 0
    while start_idx < len(cell_content) and cell_content[start_idx] == '-': start_idx += 1
    cell_content = cell_content[start_idx:]
    if not cell_content: return None, None
    fret_str, symbol_str = "", ""
    i = 0
    while i < len(cell_content) and cell_content[i].isdigit():
        fret_str += cell_content[i]
        i += 1
    symbol_str = cell_content[i:]
    fret = None
    if fret_str:
        fret = int(fret_str)
        if fret > 24: raise ValueError(f"{string_name}弦: フレット番号 {fret} は24を超えています。")
    if symbol_str:
        cleaned_symbol_str = symbol_str.replace('-', '')
        for char in cleaned_symbol_str:
            if char not in SYMBOLS: raise ValueError(f"{string_name}弦: 不正な文字 '{char}' がTABセルにあります。")
    if not fret_str and not cleaned_symbol_str: raise ValueError(f"{string_name}弦: 不正なTABセル内容: '{cell_content}'。フレット番号、'-'、または演奏記号が必要です。")
    return fret, (symbol_str if symbol_str else None)

def check_tab_format(lines):
    tab_lines = [line.strip() for line in lines if line.strip() and not line.strip().startswith('#')]
    if not tab_lines: return False, "入力がありません。"
    if len(tab_lines) % 4 != 0: return False, "行数が4の倍数ではありません。G,D,A,Eの4行セットで入力してください。"
    for i in range(0, len(tab_lines), 4):
        block, block_num = tab_lines[i:i+4], (i // 4) + 1
        expected_prefixes = ['G|', 'D|', 'A|', 'E|']
        for j in range(4):
            if not block[j].startswith(expected_prefixes[j]): return False, f"ブロック{block_num}の{j+1}行目が'{expected_prefixes[j]}'で始まっていません。"
        try: block_length = len(block[0].split('|', 1)[1])
        except IndexError: return False, f"ブロック{block_num}の1行目のフォーマットが不正です。"
        for j in range(1, 4):
            try:
                content = block[j].split('|', 1)[1]
                if len(content) != block_length: return False, f"ブロック{block_num}内で各弦の長さが統一されていません。"
            except IndexError: return False, f"ブロック{block_num}の{j+1}行目のフォーマットが不正です。"
    return True, "OK"

def parse_input(lines):
    raw_strings = []
    tab_lines_only = [l for l in lines if l.strip() and not l.strip().startswith('#')]
    for line in tab_lines_only:
        parts = line.split('|', 1)
        raw_strings.append(parts[1])
    max_len = max(len(s) for s in raw_strings) if raw_strings else 0
    raw_strings = [s.ljust(max_len, '-') for s in raw_strings]
    columns = list(zip(*raw_strings))
    parsed = [[] for _ in range(4)]
    col_idx, string_names = 0, ['G', 'D', 'A', 'E']
    while col_idx < len(columns):
        if columns[col_idx][0] == '|':
            for s_idx in range(4): parsed[s_idx].append(('BAR', None))
            col_idx += 1
            continue
        width = 1
        if (col_idx + 1 < len(columns) and any(columns[col_idx][s_idx].isdigit() and columns[col_idx+1][s_idx].isdigit() for s_idx in range(4))): width = 2
        block = columns[col_idx:col_idx+width]
        for s_idx in range(4):
            cell = "".join(row[s_idx] for row in block)
            parsed[s_idx].append(extract_fret_and_symbol(cell, string_name=string_names[s_idx]))
        col_idx += width
    return parsed, len(parsed[0]) if parsed and parsed[0] else 0

def cost(cs, cf, ps, pf): return abs(cs-ps)*3 + abs(cf-pf)

def choose_string(midi_note, prev_s, prev_f, conversion_mode, open_string_midis):
    candidates = []
    for i in range(5):
        fret = midi_note - open_string_midis[i]
        if 0 <= fret <= 24:
            current_cost = cost(i, fret, prev_s, prev_f)
            if conversion_mode == 'b_string_optimized' and i == 0: current_cost -= 1000
            candidates.append((current_cost, i, fret))
    if not candidates:
        fallback = [(i, midi_note - m) for i,m in enumerate(open_string_midis) if midi_note - m >= 0]
        return min(fallback, key=lambda x: cost(x[0], x[1], prev_s, prev_f)) if fallback else (1,0)
    return min(candidates, key=lambda x: (x[0], x[1]))[1:]

def convert_tab(parsed_4str, length, conversion_mode, open_4_string_midis_gdae):
    output, prev_s, prev_f, last_string_mapping = [[] for _ in range(5)], 2, 0, {}
    e_midi_4str, a_midi_4str, d_midi_4str, g_midi_4str = open_4_string_midis_gdae[3], open_4_string_midis_gdae[2], open_4_string_midis_gdae[1], open_4_string_midis_gdae[0]
    open_5_string_midis_beadg = [e_midi_4str - 5, e_midi_4str, a_midi_4str, d_midi_4str, g_midi_4str]
    for pos in range(length):
        if parsed_4str[0][pos][0] == 'BAR':
            for _ in range(5): output[_].append('|')
            continue
        notes_at_pos, symbols_at_pos = [], []
        for i in range(4):
            fret, sym = parsed_4str[i][pos]
            if fret is not None:
                midi = open_4_string_midis_gdae[i] + fret
                notes_at_pos.append({'midi': midi, 'symbol': sym, 'original_string_idx': i})
            elif sym is not None: symbols_at_pos.append({'symbol': sym, 'original_string_idx': i})
        for s in range(5): output[s].append('-')
        if notes_at_pos:
            notes_at_pos.sort(key=lambda x: x['midi'])
            for note in notes_at_pos:
                s5, f5 = choose_string(note['midi'], prev_s, prev_f, conversion_mode, open_5_string_midis_beadg)
                prev_s, prev_f = s5, f5
                output[s5][-1], last_string_mapping[note['original_string_idx']] = (f5, note['symbol']), s5
        for sym_info in symbols_at_pos:
            original_idx, sym = sym_info['original_string_idx'], sym_info['symbol']
            target_s5 = last_string_mapping.get(original_idx)
            if target_s5 is not None:
                if output[target_s5][-1] == '-': output[target_s5][-1] = (None, sym)
            else:
                fallback_s5_map, fallback_s5 = {0:4, 1:3, 2:2, 3:1}, fallback_s5_map[original_idx]
                if output[fallback_s5][-1] == '-': output[fallback_s5][-1] = (None, sym)
    return output

def format_output(output, open_5_string_midis_beadg):
    names = ['B','E','A','D','G']
    if not output or not any(output): return ""
    cols = len(output[0])
    widths = [1]*cols
    for ci in range(cols):
        if output[0][ci] == '|': continue
        max_w = 1
        for ri in range(5):
            cell = output[ri][ci]
            txt_for_width = str(cell)
            if isinstance(cell, tuple):
                f, s = cell
                txt_for_width = (str(f) + s) if f is not None and s else (str(f) if f is not None else s or '-')
            max_w = max(max_w, len(txt_for_width))
        widths[ci] = max_w
    note_id_counter, formatted_cells = 0, [[] for _ in range(5)]
    for ci in range(cols):
        w = widths[ci]
        for ri in range(5):
            cell, txt = output[ri][ci], ""
            if cell == '|': txt = '|'
            elif isinstance(cell, tuple):
                f,s = cell
                span_content = (str(f) if f is not None else '') + (s if s is not None else '')
                dashes = '-' * max(0, w - len(span_content))
                if f is not None:
                    midi_note = open_5_string_midis_beadg[ri] + f
                    txt = f'<span class="fret-note" data-note-id="{note_id_counter}" data-midi-note="{midi_note}" data-string-index="{ri}">{span_content}{dashes}</span>'
                    note_id_counter += 1
                else: txt = f'{span_content}{dashes}'
            else: txt = str(cell).ljust(w, '-')
            formatted_cells[ri].append(txt)
    lines = {i: "".join(formatted_cells[i]) for i in range(5)}
    final_lines, string_order = [], [names[i] for i in display_order]
    full_content = [f"{string_order[idx]}|{lines[i]}" for idx, i in enumerate(display_order)]
    measures = [line.split('|')[1:-1] for line in full_content]
    num_measures = len(measures[0]) if measures and measures[0] else 0
    for i in range(0, num_measures, 4):
        end = min(i + 4, num_measures)
        for string_idx, name in enumerate(string_order):
            line_part = '|'.join(measures[string_idx][i:end])
            final_lines.append(f"{name}|{line_part}|")
        if end < num_measures: final_lines.append("")
    return "\n".join(final_lines)

def get_template(evt):
    template = '''# 4弦TABテンプレート\n# ・G,D,A,E の4行\n# ・フレット0-24、空欄は"-"\nG|--------------------------------|\nD|--------------------------------|\nA|--------------------------------|\nE|--------------------------------|\n'''
    blob = Blob.new([template], {"type":"text/plain"})
    url = URL.createObjectURL(blob)
    a = document.createElement("a"); a.href, a.download = url, "4string_template.txt"
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url)
    document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['template_download_success']
    document.getElementById("status_message").style.color = "#4CAF50"

def run_format_check(evt):
    status_msg = document.getElementById("status_message")
    try:
        txt = document.getElementById("input_tab").value
        lines = [l.strip() for l in txt.splitlines() if l.strip()]
        ok, msg = check_tab_format(lines)
        if not ok:
            status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_format_error'].format(error=msg)
            status_msg.style.color = "#f44336"
            return
        stitched_parts, current_string_order = {'G':[], 'D':[], 'A':[], 'E':[]}, ['G', 'D', 'A', 'E']
        for i, line in enumerate(lines): stitched_parts[current_string_order[i % 4]].append(line.split('|', 1)[1])
        stitched_lines = [f"{s}|{''.join(stitched_parts[s])}" for s in current_string_order]
        parsed, length = parse_input(stitched_lines)
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_format_ok']
        status_msg.style.color = "#4CAF50"
    except Exception as e:
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_format_error'].format(error=str(e))
        status_msg.style.color = "#f44336"

def on_convert(evt):
    global CONVERTED_NOTES_DATA
    status_msg, output_area = document.getElementById("status_message"), document.getElementById("output_tab")
    try:
        txt = document.getElementById("input_tab").value
        lines = [l.strip() for l in txt.splitlines() if l.strip()]
        ok, msg = check_tab_format(lines)
        if not ok: raise ValueError(msg)
        stitched_parts, current_string_order = {'G':[], 'D':[], 'A':[], 'E':[]}, ['G', 'D', 'A', 'E']
        for i, line in enumerate(lines): stitched_parts[current_string_order[i % 4]].append(line.split('|', 1)[1])
        stitched_lines = [f"{s}|{''.join(stitched_parts[s])}" for s in current_string_order]
        tuning_dict = document.defaultView.getCustomTuning().to_py()
        open_4 = [note_to_midi(tuning_dict[s]['note'], tuning_dict[s]['octave']) for s in ['g','d','a','e']]
        open_5 = [open_4[3] - 5, open_4[3], open_4[2], open_4[1], open_4[0]]
        selected_mode = document.querySelector('input[name="conversion_mode"]:checked').value
        parsed, length = parse_input(stitched_lines)
        converted = convert_tab(parsed, length, selected_mode, open_4)
        result = format_output(converted, open_5)
        output_area.innerHTML = result
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_convert_success']
        status_msg.style.color = "#4CAF50"
        plain_text_output = document.getElementById("output_tab").textContent
        midi_notes_for_playback = [open_5[4], open_5[3], open_5[2], open_5[1], open_5[0]]
        CONVERTED_NOTES_DATA = parse_tab_for_playback(plain_text_output, 5, open_string_midis=midi_notes_for_playback)
    except Exception as e:
        output_area.textContent, CONVERTED_NOTES_DATA = "", None
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_convert_error'].format(error=str(e))
        status_msg.style.color = "#f44336"

def on_download(evt):
    out, status_msg = document.getElementById("output_tab").textContent, document.getElementById("status_message")
    if not out.strip():
        status_msg.textContent, status_msg.style.color = LANGUAGES[CURRENT_LANG]['status_download_empty'], "#f44336"
        return
    blob = Blob.new([out], {"type":"text/plain"})
    url = URL.createObjectURL(blob)
    a = document.createElement("a"); a.href, a.download = url, "5-string_tab_result.txt"
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url)
    status_msg.textContent, status_msg.style.color = LANGUAGES[CURRENT_LANG]['status_download_success'], "#4CAF50"

def parse_tab_for_playback(tab_string, num_strings, tuning_data=None, open_string_midis=None):
    lines = [l.strip() for l in tab_string.splitlines() if l.strip() and not l.strip().startswith('#')]
    if not lines or len(lines) % num_strings != 0: return []
    string_order = ['G', 'D', 'A', 'E'] if num_strings == 4 else ['G', 'D', 'A', 'E', 'B']
    parts = {s: [] for s in string_order}
    for line in lines:
        if line[0] in parts: parts[line[0]].append(line.split('|', 1)[1])
    stitched_content = {s: "".join(parts[s]) for s in string_order}
    base_midi_notes = []
    if open_string_midis: base_midi_notes = open_string_midis
    elif num_strings == 4:
        if tuning_data:
            d = tuning_data.to_py()
            base_midi_notes = [note_to_midi(d['g']['note'],d['g']['octave']), note_to_midi(d['d']['note'],d['d']['octave']), note_to_midi(d['a']['note'],d['a']['octave']), note_to_midi(d['e']['note'],d['e']['octave'])]
        else: base_midi_notes = [79, 74, 69, 64]
    elif num_strings == 5: base_midi_notes = [79, 74, 69, 64, 59]
    notes_data, max_len = [], max(len(v) for v in stitched_content.values()) if stitched_content and any(stitched_content.values()) else 0
    tick_per_unit, musical_pos, char_idx, note_id_counter = 120, 0, 0, 0
    while char_idx < max_len:
        notes_in_col, width = [], 1
        w_check = 1
        for s_name in string_order:
            content = stitched_content.get(s_name, '')
            if char_idx < len(content) and content[char_idx].isdigit():
                f_str, t_idx = "", char_idx
                while t_idx < len(content) and content[t_idx].isdigit(): f_str, t_idx = f_str + content[t_idx], t_idx + 1
                w_check = max(w_check, len(f_str))
        width = w_check
        s_map = {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
        for s_idx, s_name in enumerate(string_order):
            content = stitched_content.get(s_name, '')
            if char_idx < len(content) and content[char_idx].isdigit():
                if char_idx == 0 or (char_idx > 0 and not content[char_idx-1].isdigit()):
                    f_str, t_idx = "", char_idx
                    while t_idx < len(content) and content[t_idx].isdigit(): f_str, t_idx = f_str + content[t_idx], t_idx + 1
                    if base_midi_notes and s_idx < len(base_midi_notes):
                        midi = base_midi_notes[s_idx] + int(f_str)
                        internal_s_idx = s_map.get(s_idx, s_idx)
                        notes_in_col.append({'midi': midi, 'string_idx': internal_s_idx, 'note_id': note_id_counter})
                        note_id_counter += 1
        if notes_in_col: notes_data.append({'tick': musical_pos * tick_per_unit, 'notes': notes_in_col, 'durationTicks': tick_per_unit})
        char_idx, musical_pos = char_idx + width, musical_pos + 1
    return notes_data

def prepare_and_play(evt):
    tab_type = 'input' if 'input' in evt.target.id else 'output'
    if tab_type == 'input':
        tab_string = document.getElementById("input_tab").value
        notes = parse_tab_for_playback(tab_string, 4, document.defaultView.getCustomTuning())
    else:
        if not CONVERTED_NOTES_DATA:
            document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_download_empty']
            document.getElementById("status_message").style.color = "#f44336"
            return
        notes = CONVERTED_NOTES_DATA
    if not notes:
        document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_no_notes_to_play']
        document.getElementById("status_message").style.color = "#f44336"
        return
    document.defaultView.playAudioFromData(json.dumps(notes))

def prepare_and_export_midi(evt):
    if not CONVERTED_NOTES_DATA:
        document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_no_notes_to_export']
        document.getElementById("status_message").style.color = "#f44336"
        return
    notes = CONVERTED_NOTES_DATA
    document.defaultView.exportMidiFromData(json.dumps(notes))
    document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_midi_exported']
    document.getElementById("status_message").style.color = "#4CAF50"

def setup_event_listeners():
    document.getElementById("get_template_btn").addEventListener("click", create_proxy(get_template))
    document.getElementById("format_check_btn").addEventListener("click", create_proxy(run_format_check))
    document.getElementById("convert_btn").addEventListener("click", create_proxy(on_convert))
    document.getElementById("download_btn").addEventListener("click", create_proxy(on_download))
    document.getElementById("lang-ja").addEventListener("click", create_proxy(lambda e: set_language('ja')))
    document.getElementById("lang-en").addEventListener("click", create_proxy(lambda e: set_language('en')))
    document.getElementById("play_input_btn").addEventListener("click", create_proxy(prepare_and_play))
    document.getElementById("play_output_btn").addEventListener("click", create_proxy(prepare_and_play))
    document.getElementById("export_midi_btn").addEventListener("click", create_proxy(prepare_and_export_midi))

setup_event_listeners()
set_language('ja')
</py-script>

<script src="https://cdn.jsdelivr.net/npm/midi-writer-js@2.1.4/dist/midi-writer-js.min.js"></script>
<script>
    let audioContext; 
    let currentPlayback = { stop: () => {} }; 

    function getNoteFrequency(midiNote) {
        return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    async function playAudioFromData(notesJson) {
        if (currentPlayback && typeof currentPlayback.stop === 'function') {
            currentPlayback.stop();
        }

        const notesData = JSON.parse(notesJson);
        if (notesData.length === 0) return;

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const scheduledOscillators = [];
        const highlightedElements = new Set();

        const bpm = document.getElementById('bpm_input').value;
        const ticksPerBeat = 480; 
        const secondsPerTick = 60 / (bpm * ticksPerBeat); 
        const startTime = audioContext.currentTime + 0.1;

        notesData.forEach(event => {
            const time = startTime + event.tick * secondsPerTick;
            const duration = event.durationTicks * secondsPerTick;
            
            let noteDelay = 0;
            const staggerDelay = 0.05;

            event.notes.sort((a, b) => a.string_idx - b.string_idx);

            event.notes.forEach((noteInfo) => {
                const currentNoteTime = time + noteDelay;
                const frequency = getNoteFrequency(noteInfo.midi);

                // --- Fret Highlighting Logic (MODIFIED) ---
                const fretElement = document.querySelector(
                    `#output_tab span.fret-note[data-note-id="${noteInfo.note_id}"]`
                );

                if (fretElement) {
                    const element = fretElement;
                    const highlightStartTime = Math.max(currentNoteTime, audioContext.currentTime);
                    const highlightEndTime = Math.max(currentNoteTime + duration, audioContext.currentTime);

                    if (highlightStartTime >= audioContext.currentTime) {
                        setTimeout(() => {
                            element.classList.add('playing-fret');
                            highlightedElements.add(element);
                        }, (highlightStartTime - audioContext.currentTime) * 1000);
                    } else {
                        element.classList.add('playing-fret');
                        highlightedElements.add(element);
                    }

                    if (highlightEndTime >= audioContext.currentTime) {
                        setTimeout(() => {
                            element.classList.remove('playing-fret');
                            highlightedElements.delete(element);
                        }, (highlightEndTime - audioContext.currentTime) * 1000);
                    }
                }

                const osc1 = audioContext.createOscillator();
                osc1.type = 'sawtooth'; 
                osc1.frequency.setValueAtTime(frequency, currentNoteTime);

                const osc2 = audioContext.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(frequency / 2, currentNoteTime);

                const gainNode = audioContext.createGain();
                const osc1Gain = audioContext.createGain();
                osc1Gain.gain.setValueAtTime(0.7, currentNoteTime);
                osc1.connect(osc1Gain);
                osc1Gain.connect(gainNode);

                const osc2Gain = audioContext.createGain();
                osc2Gain.gain.setValueAtTime(0.3, currentNoteTime);
                osc2.connect(osc2Gain);
                osc2Gain.connect(gainNode);

                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, currentNoteTime);
                filter.Q.setValueAtTime(1, currentNoteTime);
                gainNode.connect(filter);
                filter.connect(audioContext.destination);

                gainNode.gain.setValueAtTime(0, currentNoteTime);
                gainNode.gain.linearRampToValueAtTime(0.8, currentNoteTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.4, currentNoteTime + 0.1);
                gainNode.gain.setValueAtTime(0.4, currentNoteTime + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, currentNoteTime + duration);

                osc1.start(currentNoteTime);
                osc2.start(currentNoteTime);
                osc1.stop(currentNoteTime + duration + 0.1);
                osc2.stop(currentNoteTime + duration + 0.1); 

                scheduledOscillators.push(osc1, osc2);
                noteDelay += staggerDelay;
            });
        });

        currentPlayback = {
            stop: () => {
                if (audioContext && audioContext.state !== 'closed') {
                    scheduledOscillators.forEach(osc => { try { osc.stop(0); } catch (e) {} });
                    highlightedElements.forEach(element => {
                        element.classList.remove('playing-fret');
                    });
                    highlightedElements.clear();
                    audioContext.close().then(() => { audioContext = null; });
                }
            }
        };
    }

    function exportMidiFromData(notesJson) {
        const notesData = JSON.parse(notesJson);
        if (notesData.length === 0) return;

        const bpm = document.getElementById('bpm_input').value;
        const writer = new MidiWriter.Writer();
        const track = new MidiWriter.Track();
        track.setTempo(bpm);
        track.addTrackName('Bass');
        track.addInstrumentName('Electric Bass (finger)');
        
        notesData.forEach(event => {
            track.addEvent(new MidiWriter.NoteEvent({
                pitch: event.notes.map(n => n.midi),
                tick: event.tick,
                duration: `T${event.durationTicks}`
            }));
        });

        writer.addTrack(track);
        const a = document.createElement('a');
        a.href = writer.dataUri();
        a.download = '5string_tab_export.mid';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const stringConfigs = [
        { id: 'g', label: 'G-String', defaultNote: 'G', defaultOctave: 2 },
        { id: 'd', label: 'D-String', defaultNote: 'D', defaultOctave: 2 },
        { id: 'a', label: 'A-String', defaultNote: 'A', defaultOctave: 1 },
        { id: 'e', label: 'E-String', defaultNote: 'E', defaultOctave: 1 },
    ];

    function setupCustomTuningUI() {
        const container = document.getElementById('custom-tuning-area');
        container.innerHTML = '';

        stringConfigs.forEach(s => {
            const stringGroup = document.createElement('div');
            stringGroup.className = 'tuning-string-group';

            const labelSpan = document.createElement('span');
            labelSpan.className = 'string-label';
            labelSpan.textContent = s.label;
            stringGroup.appendChild(labelSpan);

            const noteSelect = document.createElement('select');
            noteSelect.className = 'note-select';
            noteSelect.id = `${s.id}-note`;
            noteNames.forEach(note => {
                const option = document.createElement('option');
                option.value = note;
                option.textContent = note;
                noteSelect.appendChild(option);
            });
            stringGroup.appendChild(noteSelect);

            const octaveSelect = document.createElement('select');
            octaveSelect.className = 'octave-select';
            octaveSelect.id = `${s.id}-octave`;
            for (let i = 0; i <= 5; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                octaveSelect.appendChild(option);
            }
            stringGroup.appendChild(octaveSelect);

            container.appendChild(stringGroup);
        });

        setTuningPreset('standard');

        document.getElementById('tuning-presets').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const preset = e.target.dataset.tuning;
                if (preset) {
                    setTuningPreset(preset);
                } 
            } 
        });
    }

    function setTuningPreset(preset) {
        let tunings;
        switch (preset) {
            case 'half_down':
                tunings = { g: ['F#', 2], d: ['C#', 2], a: ['G#', 1], e: ['D#', 1] };
                break;
            case 'drop_d':
                tunings = { g: ['G', 2], d: ['D', 2], a: ['A', 1], e: ['D', 1] };
                break;
            case 'standard':
            default:
                tunings = { g: ['G', 2], d: ['D', 2], a: ['A', 1], e: ['E', 1] };
                break;
        }
        for (const strId in tunings) {
            document.getElementById(`${strId}-note`).value = tunings[strId][0];
            document.getElementById(`${strId}-octave`).value = tunings[strId][1];
        }
        
        const buttons = document.querySelectorAll('#tuning-presets button');
        buttons.forEach(btn => {
            if (btn.dataset.tuning === preset) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    function getCustomTuning() {
        const tuning = {};
        stringConfigs.forEach(s => {
            const note = document.getElementById(`${s.id}-note`).value;
            const octave = document.getElementById(`${s.id}-octave`).value;
            tuning[s.id] = {note, octave: parseInt(octave)};
        });
        return tuning;
    }

    window.getCustomTuning = getCustomTuning;

    document.addEventListener('DOMContentLoaded', () => {
        setupCustomTuningUI();
    });
</script>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const downloadPdfBtn = document.getElementById('download_pdf_btn');
        if (downloadPdfBtn) {
            downloadPdfBtn.addEventListener('click', async () => {
                const statusMessage = document.getElementById('status_message');
                statusMessage.textContent = 'PDFを生成中...';
                statusMessage.style.color = '#007acc';

                try {
                    const rawTabContent = document.getElementById('output_tab').textContent;
                    if (!rawTabContent.trim()) {
                        throw new Error('変換結果がありません。先に5弦TABに変換してください。');
                    }

                    // --- TAB譜の整形ロジック ---
                    const lines = rawTabContent.split('\n').map(line => line.trim()).filter(line => line.length > 0 && !line.startsWith('#'));
                    
                    let numStrings = 4;
                    let stringPrefixes = ['G|', 'D|', 'A|', 'E|'];
                    let stringMap = { 'G|': 0, 'D|': 1, 'A|': 2, 'E|': 3 };

                    // Check if it's a 5-string tab by looking for 'B|'
                    if (lines.some(line => line.startsWith('B|'))) {
                        numStrings = 5;
                        stringPrefixes = ['B|', 'E|', 'A|', 'D|', 'G|'];
                        stringMap = { 'B|': 0, 'E|': 1, 'A|': 2, 'D|': 3, 'G|': 4 };
                    }

                    const allMeasures = Array.from({ length: numStrings }, () => []); // Initialize with correct number of arrays

                    // 各弦の全ての小節を抽出 (内容と長さを保持)
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        let foundPrefix = stringPrefixes.find(prefix => line.startsWith(prefix));
                        if (foundPrefix) {
                            let stringIndex = stringMap[foundPrefix];
                            const content = line.substring(line.indexOf('|') + 1);
                            const measures = content.split('|').filter(m => m.length > 0);
                            measures.forEach(m => allMeasures[stringIndex].push({ content: m, length: m.length }));
                        }
                    }

                    const formattedTabLines = [];
                    let currentGlobalMeasureIndex = 0;
                    const maxMeasuresPerOutputLine = 4; // 1行あたりの小節数

                    // Define display order for 5-string tab
                    const displayOrder5String = ['G|', 'D|', 'A|', 'E|', 'B|'];
                    const displayOrder4String = ['G|', 'D|', 'A|', 'E|']; // Keep for 4-string case

                    // Determine which display order to use
                    const currentDisplayOrder = numStrings === 5 ? displayOrder5String : displayOrder4String;

                    // 全ての弦の中で最も長い小節リストの長さを取得
                    const maxTotalMeasures = Math.max(...allMeasures.map(arr => arr.length));

                    while (currentGlobalMeasureIndex < maxTotalMeasures) {
                        const measuresForCurrentOutputLine = Array.from({ length: numStrings }, () => []); // Initialize with correct number of arrays
                        let measuresAddedToOutputLine = 0;

                        // 現在の出力行に含める小節を収集
                        while (measuresAddedToOutputLine < maxMeasuresPerOutputLine && (currentGlobalMeasureIndex + measuresAddedToOutputLine) < maxTotalMeasures) {
                            const currentColumnIndex = currentGlobalMeasureIndex + measuresAddedToOutputLine;
                            let maxMeasureWidthForCurrentColumn = 0;

                            // まず、現在の列（小節位置）における最大幅を計算
                            for (let s = 0; s < numStrings; s++) {
                                if (currentColumnIndex < allMeasures[s].length) {
                                    maxMeasureWidthForCurrentColumn = Math.max(maxMeasureWidthForCurrentColumn, allMeasures[s][currentColumnIndex].length);
                                }
                            }
                            // もし小節が全くない場合（例: 最後のブロックで小節が足りない場合）、デフォルトの幅を設定
                            if (maxMeasureWidthForCurrentColumn === 0) {
                                maxMeasureWidthForCurrentColumn = 10; // デフォルトの幅
                            }

                            // 各弦の小節を収集し、最大幅に合わせてパディング
                            for (let s = 0; s < numStrings; s++) {
                                if (currentColumnIndex < allMeasures[s].length) {
                                    const measure = allMeasures[s][currentColumnIndex].content;
                                    measuresForCurrentOutputLine[s].push(measure.padEnd(maxMeasureWidthForCurrentColumn, '-'));
                                } else {
                                    // 該当する弦に小節がない場合、空白で埋める
                                    measuresForCurrentOutputLine[s].push(' '.repeat(maxMeasureWidthForCurrentColumn));
                                }
                            }
                            measuresAddedToOutputLine++;
                        }

                        if (measuresAddedToOutputLine > 0) {
                            // Iterate based on desired display order
                            for (let i = 0; i < numStrings; i++) {
                                const prefix = currentDisplayOrder[i];
                                const stringIndex = stringMap[prefix]; // Get the internal index for this prefix
                                formattedTabLines.push(prefix + measuresForCurrentOutputLine[stringIndex].join('|') + '|');
                            }
                            formattedTabLines.push(''); // ブロック間の空行
                        }
                        currentGlobalMeasureIndex += measuresAddedToOutputLine;
                    }

                    const formattedTab = formattedTabLines.join('\n');

                    // --- PDF生成 ---
                    const { jsPDF } = window.jspdf;
                    // Initialize in portrait mode (default), A4 size
                    const doc = new jsPDF({ unit: 'pt', format: 'a4' });

                    doc.setFont('courier'); // TAB譜に適した等幅フォント
                    doc.setFontSize(8); // Reduced font size

                    // Use a wider width for text splitting, almost full page width minus margins
                    const textLines = doc.splitTextToSize(formattedTab, doc.internal.pageSize.getWidth() - 20); // 10pt margin on each side
                    let y = 10;
                    const lineHeight = 8; // Increased line height for better spacing

                    textLines.forEach(line => {
                        if (y > 280) { // ページの下部に達したら新しいページを追加
                            doc.addPage();
                            y = 10;
                        }
                        doc.text(line, 10, y);
                        y += lineHeight;
                    });

                    doc.save('bass_tab_converted.pdf');

                    statusMessage.textContent = 'PDFを生成し、ダウンロードしました。';
                    statusMessage.style.color = '#4CAF50';

                } catch (error) {
                    console.error('PDF生成エラー:', error);
                    statusMessage.textContent = `PDF生成中にエラーが発生しました: ${error.message}`;
                    statusMessage.style.color = '#f44336';
                }
            });
        }
    });
</script>
