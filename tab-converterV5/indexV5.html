<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>çµ±åˆTABå¤‰æ›ãƒ„ãƒ¼ãƒ«</title>
    <link rel="stylesheet" href="./core.css" />
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: Consolas, monospace;
            margin: 20px;
            background-color: #2e2e2e;
            color: #f7f7f7;
        }
        h1 {
            color: #007acc;
            text-align: center;
            margin-bottom: 20px;
        }
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        #lang-switcher button {
            background: none;
            border: 1px solid #007acc;
            color: #007acc;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 5px;
            margin-left: 5px;
        }
        #lang-switcher button.active {
            background: #007acc;
            color: white;
        }
        textarea, pre {
            width: 100%;
            min-height: 120px; /* Reduced */
            font-family: Consolas, monospace;
            font-size: 14px;
            margin-bottom: 10px; /* Reduced */
            padding: 10px;
            background-color: #3e3e3e;
            color: #f7f7f7;
            border: 1px solid #007acc;
            white-space: pre-wrap;
            word-break: break-word;
            resize: vertical;
        }
        #chord_input {
            height: 60px;
            min-height: 60px;
        }
        .button-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 12px;
            font-size: 16px;
            background-color: #007acc;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
        }
        button:hover {
            background-color: #005a9e;
        }
        .message {
            margin-top: 20px;
            font-weight: bold;
            color: #4CAF50;
        }
        py-terminal,
        py-repl,
        .py-terminal,
        .py-repl,
        .py-error,
        .pyscript {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        /* tab_converter.html ã‹ã‚‰ã®è¿½åŠ CSS */
        .tuning-options {
            margin-bottom: 15px;
            border: 1px solid #007acc;
            padding: 10px;
            border-radius: 5px;
            background-color: #3e3e3e;
        }
        .tuning-options b {
            color: #f7f7f7;
        }
        .tuning-options .btn-group .btn {
            background-color: #555;
            color: #f7f7f7;
            border-color: #007acc;
        }
        .tuning-options .btn-group .btn.active {
            background-color: #007acc;
            color: white;
        }
        /* UIèª¿æ•´ã®ãŸã‚ã®æ–°ã—ã„CSS */
        #custom-tuning-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around; /* Adjust as needed */
            gap: 10px; /* Space between string groups */
            margin-top: 10px;
        }
        .tuning-string-group {
            display: flex;
            flex-direction: row; /* Change to row for horizontal alignment */
            align-items: center; /* Vertically center items */
            justify-content: space-between; /* Distribute space between items */
            flex: 1; /* Make them grow equally */
            min-width: 200px; /* Ensure a minimum width to prevent squishing */
            max-width: 24%; /* Allow wrapping, roughly 4 per row */
            padding: 5px 10px; /* Adjust padding */
            border: 1px solid #444;
            border-radius: 5px;
            background-color: #4a4a4a;
            box-sizing: border-box; /* Include padding and border in the element's total width */
        }
        .tuning-string-group .string-label {
            font-weight: bold;
            margin-right: 10px; /* Space between label and selects */
            color: #f7f7f7;
            white-space: nowrap; /* Prevent label from wrapping */
        }
        .tuning-string-group select {
            width: 60px; /* Adjust width for selects */
            margin-bottom: 0; /* Remove bottom margin */
            margin-left: 5px; /* Space between selects */
            background-color: #5e5e5e;
            color: #f7f7f7;
            border-color: #007acc;
        }
        .fret-note.playing-fret {
            background-color: yellow; /* Or any other highlighting color */
            color: #2e2e2e; /* Change text color for better visibility */
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="header-container">
    <h1 data-lang-key="app_title">ğŸ¸ çµ±åˆTABå¤‰æ›ãƒ„ãƒ¼ãƒ«</h1>
    <div id="lang-switcher">
        <button id="lang-ja">æ—¥æœ¬èª</button>
        <button id="lang-en">English</button>
    </div>
</div>
<p data-lang-key="app_description">4å¼¦ãƒ™ãƒ¼ã‚¹ã¨5å¼¦ãƒ™ãƒ¼ã‚¹ã®TABè­œã‚’ç›¸äº’ã«å¤‰æ›ã—ã¾ã™ã€‚</p>
<p data-lang-key="instructions">TABè­œ (ã‚³ãƒ¡ãƒ³ãƒˆè¡Œå«ã‚€) ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:</p>

<div class="conversion-options">
    <label>
        <input type="radio" name="conversion_direction" value="4to5" checked>
        <span data-lang-key="direction_4to5">4å¼¦ â†’ 5å¼¦</span>
    </label>
    <label>
        <input type="radio" name="conversion_direction" value="5to4">
        <span data-lang-key="direction_5to4">5å¼¦ â†’ 4å¼¦</span>
    </label>
</div>

<div id="4to5_options">
    <div class="conversion-options">
        <label>
            <input type="radio" name="conversion_mode" value="standard" checked>
            <span data-lang-key="conversion_mode_standard">æ¨™æº–5å¼¦å¤‰æ›</span>
        </label>
        <label>
            <input type="radio" name="conversion_mode" value="b_string_optimized">
            <span data-lang-key="conversion_mode_b_string_optimized">Bå¼¦å„ªå…ˆ5å¼¦å¤‰æ›</span>
        </label>
    </div>

    <div class="tuning-options">
        <b data-lang-key="tuning_options_title">ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°è£œæ­£ã‚ªãƒ—ã‚·ãƒ§ãƒ³</b>
        
        <div class="btn-group btn-group-sm my-2" role="group" id="tuning-presets">
            <button type="button" class="btn btn-outline-secondary" data-tuning="standard" data-lang-key="tuning_standard">é€šå¸¸</button>
            <button type="button" class="btn btn-outline-secondary" data-tuning="half_down" data-lang-key="tuning_half_down">åŠéŸ³ä¸‹ã’</button>
            <button type="button" class="btn btn-outline-secondary" data-tuning="drop_d" data-lang-key="tuning_drop_d">ãƒ‰ãƒ­ãƒƒãƒ—D</button>
        </div>

        <div id="custom-tuning-area"></div>
    </div>
</div>

<textarea id="input_tab" data-lang-key-placeholder="placeholder_text_4_string" placeholder="ã“ã“ã«4å¼¦TABï¼ˆG|... D|... A|... E|...ï¼‰ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„"></textarea>

<div id="chord-generation-section" style="margin-bottom: 20px;">
    <p data-lang-key="instructions_chords">ã‚³ãƒ¼ãƒ‰è­œã‚’å…¥åŠ›ã—ã¦ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆ:</p>
    <textarea id="chord_input" placeholder="ä¾‹: Am7 | D7 | Gmaj7 | Cmaj7" style="height: 60px;"></textarea>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <select id="genre_select" style="padding: 8px; background-color: #3e3e3e; color: #f7f7f7; border: 1px solid #007acc;">
            <option value="rock" data-lang-key="genre_rock">ãƒ­ãƒƒã‚¯</option>
            <option value="jazz" data-lang-key="genre_jazz">ã‚¸ãƒ£ã‚º</option>
            <option value="funk" data-lang-key="genre_funk">ãƒ•ã‚¡ãƒ³ã‚¯</option>
        </select>
        <button id="generate_bassline_btn" data-lang-key="btn_generate_bassline">ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’ç”Ÿæˆ</button>
    </div>
</div>

<div class="bpm-container" style="margin-bottom: 10px; text-align: right; display: flex; align-items: center; justify-content: flex-end;">
    <label style="color: #f7f7f7; margin-right: 10px;">
        <input type="checkbox" id="metronome_enabled">
        <span data-lang-key="metronome_enable">ãƒ¡ãƒˆãƒ­ãƒãƒ¼ãƒ </span>
    </label>
    <label for="bpm_input" style="color: #f7f7f7;">BPM: </label>
    <input type="number" id="bpm_input" value="120" min="40" max="300" style="width: 60px; background-color: #3e3e3e; color: #f7f7f7; border: 1px solid #007acc; padding: 5px; border-radius: 5px;">
</div>

<div class="button-container">
    <button id="play_input_btn" data-lang-key="btn_play_input">â–¶ å†ç”Ÿ (å…¥åŠ›)</button>
    <button id="get_template_btn" data-lang-key="btn_get_template">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆDL (.txt)</button>
    <button id="format_check_btn" data-lang-key="btn_format_check">ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯</button>
    <button id="convert_btn" data-lang-key="btn_convert_to_5_string">5å¼¦TABã«å¤‰æ›</button>
    <button id="play_output_btn" data-lang-key="btn_play_output">â–¶ å†ç”Ÿ (å‡ºåŠ›)</button>
    <button id="export_midi_btn" data-lang-key="btn_export_midi">MIDIã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
    <button id="download_btn" data-lang-key="btn_download_txt">å¤‰æ›çµæœDL (.txt)</button>
    <button id="download_pdf_btn">å¤‰æ›çµæœDL (.pdf)</button>
</div>

<p class="message" id="status_message"></p>
<pre id="output_tab"></pre>

<py-script>
from js import document, Blob, URL, Event
from pyodide.ffi import create_proxy
import json

LANGUAGES = {
    'ja': {
        'app_title': "ğŸ¸ çµ±åˆTABå¤‰æ›ãƒ»ä½œæ›²æ”¯æ´ãƒ„ãƒ¼ãƒ«",
        'app_description': "4å¼¦ãƒ™ãƒ¼ã‚¹ã¨5å¼¦ãƒ™ãƒ¼ã‚¹ã®TABè­œã‚’ç›¸äº’ã«å¤‰æ›ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰è­œã‹ã‚‰ã®ä½œæ›²æ”¯æ´æ©Ÿèƒ½ã‚‚æ­è¼‰ã€‚",
        'instructions': "TABè­œ (ã‚³ãƒ¡ãƒ³ãƒˆè¡Œå«ã‚€) ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:",
        'placeholder_text_4_string': "ã“ã“ã«4å¼¦TABï¼ˆG|... D|... A|... E|...ï¼‰ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„",
        'placeholder_text_5_string': "ã“ã“ã«5å¼¦TABï¼ˆB|... E|... A|... D|... G|...ï¼‰ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„",
        'btn_get_template': "ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆDL (.txt)",
        'btn_format_check': "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯",
        'btn_convert_to_5_string': "5å¼¦TABã«å¤‰æ›",
        'btn_convert_to_4_string': "4å¼¦TABã«å¤‰æ›",
        'btn_download_txt': "å¤‰æ›çµæœDL (.txt)",
        'status_template_success': "ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒå…¥åŠ›æ¬„ã«è¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚â¬†ï¸",
        'status_format_ok': "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒã‚§ãƒƒã‚¯: OK âœ…",
        'status_format_error': "ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {error} âŒ",
        'status_check_5_string_format_error': "5å¼¦TABã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {error} âŒ",
        'status_convert_success': "å¤‰æ›æˆåŠŸï¼ä¸‹ã®æ¬„ã«5å¼¦TABãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚ğŸ‰",
        'status_convert_5to4_success': "å¤‰æ›æˆåŠŸï¼ä¸‹ã®æ¬„ã«4å¼¦TABãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚ğŸ‰",
        'status_convert_error': "å¤‰æ›ä¸­ã«ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {error}",
        'status_download_success': "å¤‰æ›çµæœã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚",
        'status_download_empty': "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å¤‰æ›çµæœãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚",
        'template_download_success': "ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚",
        'conversion_mode_standard': "æ¨™æº–5å¼¦å¤‰æ›",
        'conversion_mode_b_string_optimized': "Bå¼¦å„ªå…ˆ5å¼¦å¤‰æ›",
        'tuning_options_title': "ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°è£œæ­£ã‚ªãƒ—ã‚·ãƒ§ãƒ³",
        'tuning_standard': "é€šå¸¸",
        'tuning_half_down': "åŠéŸ³ä¸‹ã’",
        'tuning_drop_d': "ãƒ‰ãƒ­ãƒƒãƒ—D",
        'direction_4to5': "4å¼¦ â†’ 5å¼¦",
        'direction_5to4': "5å¼¦ â†’ 4å¼¦",
        'btn_play_input': "â–¶ å†ç”Ÿ (å…¥åŠ›)",
        'btn_play_output': "â–¶ å†ç”Ÿ (å‡ºåŠ›)",
        'btn_export_midi': "MIDIã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ",
        'status_no_notes_to_play': "å†ç”Ÿã™ã‚‹éŸ³ç¬¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        'status_no_notes_to_export': "ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹éŸ³ç¬¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        'status_midi_exported': "MIDIãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚",
        'instructions_chords': "ã‚³ãƒ¼ãƒ‰è­œã‚’å…¥åŠ›ã—ã¦ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’è‡ªå‹•ç”Ÿæˆ:",
        'genre_rock': "ãƒ­ãƒƒã‚¯",
        'genre_jazz': "ã‚¸ãƒ£ã‚º",
        'genre_funk': "ãƒ•ã‚¡ãƒ³ã‚¯",
        'btn_generate_bassline': "ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã‚’ç”Ÿæˆ",
        'metronome_enable': "ãƒ¡ãƒˆãƒ­ãƒãƒ¼ãƒ ",
        'status_bassline_generated': "ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãŒç”Ÿæˆã•ã‚Œã€å…¥åŠ›æ¬„ã«æŒ¿å…¥ã•ã‚Œã¾ã—ãŸã€‚",
        'status_bassline_error': "ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {error}"
    },
    'en': {
        'app_title': "ğŸ¸ Integrated TAB Converter & Composition Helper",
        'app_description': "Convert 4-string and 5-string bass TABs mutually.",
        'instructions': "Enter TAB (including comment lines):",
        'placeholder_text_4_string': "Paste your 4-string TAB here (G|... D|... A|... E|...)",
        'placeholder_text_5_string': "Paste your 5-string TAB here (B|... E|... A|... D|... G|...)",
        'btn_get_template': "Download Template (.txt)",
        'btn_format_check': "Check Format",
        'btn_convert_to_5_string': "Convert to 5-String TAB",
        'btn_convert_to_4_string': "Convert to 4-String TAB",
        'btn_download_txt': "Download Result (.txt)",
        'status_template_success': "Template has been loaded into the input area. â¬†ï¸",
        'status_format_ok': "Format Check: OK âœ…",
        'status_format_error': "Format Error: {error}",
        'status_check_5_string_format_error': "5-string TAB Format Error: {error}",
        'status_convert_success': "Conversion successful! 5-string TAB is shown below. ğŸ‰",
        'status_convert_5to4_success': "Conversion successful! 4-string TAB is shown below. ğŸ‰",
        'status_convert_error': "Error during conversion: {error}",
        'status_download_success': "Downloaded the conversion result.",
        'status_download_empty': "No result to download. Please convert first.",
        'template_download_success': "Template file downloaded.",
        'conversion_mode_standard': "Standard 5-string Conversion",
        'conversion_mode_b_string_optimized': "B-string Optimized 5-string Conversion",
        'tuning_options_title': "Tuning Correction Options",
        'tuning_standard': "Standard",
        'tuning_half_down': "Half-step down",
        'tuning_drop_d': "Drop D",
        'direction_4to5': "4-String â†’ 5-String",
        'direction_5to4': "5-String â†’ 4-String",
        'btn_play_input': "â–¶ Play (Input)",
        'btn_play_output': "â–¶ Play (Output)",
        'btn_export_midi': "Export MIDI",
        'status_no_notes_to_play': "No notes to play.",
        'status_no_notes_to_export': "No notes to export.",
        'status_midi_exported': "MIDI file exported.",
        'instructions_chords': "Enter chords to generate a bassline:",
        'genre_rock': "Rock",
        'genre_jazz': "Jazz",
        'genre_funk': "Funk",
        'btn_generate_bassline': "Generate Bassline",
        'metronome_enable': "Metronome",
        'status_bassline_generated': "Bassline generated and inserted into the input area.",
        'status_bassline_error': "Error generating bassline: {error}"
    }
}
CURRENT_LANG = 'ja'
CONVERTED_NOTES_DATA = None
SYMBOLS = ['h', 'p', 'b', '^', 'v', '~', 'x']
NOTE_MAP = {'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11}

def note_to_midi(note_name, octave):
    note_val = NOTE_MAP.get(note_name.upper())
    if note_val is None: return 0
    return note_val + (octave + 1) * 12

def get_note_name_from_midi(midi_note):
    if midi_note is None: return None
    note_index = midi_note % 12
    for name, index in NOTE_MAP.items():
        if index == note_index:
            return name
    return None

def set_language(lang):
    global CURRENT_LANG
    CURRENT_LANG = lang
    translations = LANGUAGES[lang]
    # Update texts based on data-lang-key
    for element in document.querySelectorAll("[data-lang-key]"):
        key = element.getAttribute("data-lang-key")
        if key in translations:
            # Handle span inside button/label
            child_span = element.querySelector("span")
            if child_span:
                child_span.textContent = translations[key]
            else:
                element.textContent = translations[key]
    # Update placeholders
    for element in document.querySelectorAll("[data-lang-key-placeholder]"):
        key = element.getAttribute("data-lang-key-placeholder")
        if key in translations:
            element.setAttribute("placeholder", translations[key])
    # Update active language button
    document.getElementById("lang-ja").classList.toggle('active', lang == 'ja')
    document.getElementById("lang-en").classList.toggle('active', lang == 'en')
    # Manually trigger UI update for conversion direction
    document.querySelector('input[name="conversion_direction"]:checked').dispatchEvent(create_proxy(document.defaultView.Event.new('change')))

def extract_fret_and_symbol(cell_content, string_name=""):
    if not cell_content: raise ValueError(f"{string_name}å¼¦: ç©ºã®ã‚»ãƒ«ã§ã™ã€‚ à¦¸à¦¨à¦¾à¦•à§à¦¤à¦•à¦°à¦£à§‡ à¦¤à§à¦°à§à¦Ÿà¦¿")
    if all(c == '-' for c in cell_content): return None, None
    start_idx = 0
    while start_idx < len(cell_content) and cell_content[start_idx] == '-': start_idx += 1
    cell_content = cell_content[start_idx:]
    if not cell_content: return None, None
    fret_str, symbol_str = "", ""
    i = 0
    while i < len(cell_content) and cell_content[i].isdigit():
        fret_str += cell_content[i]
        i += 1
    symbol_str = cell_content[i:]
    fret = None
    if fret_str:
        fret = int(fret_str)
        if fret > 24: raise ValueError(f"{string_name}å¼¦: ãƒ•ãƒ¬ãƒƒãƒˆç•ªå· {fret} ã¯24ã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚ à¦¸à¦¨à¦¾à¦•à§à¦¤à¦•à¦°à¦£à§‡ à¦¤à§à¦°à§à¦Ÿà¦¿")
    if symbol_str:
        cleaned_symbol_str = symbol_str.replace('-', '')
        for char in cleaned_symbol_str:
            if char not in SYMBOLS: raise ValueError(f"{string_name}å¼¦: ä¸æ­£ãªæ–‡å­— '{char}' ãŒTABã‚»ãƒ«ã«ã‚ã‚Šã¾ã™ã€‚ à¦¸à¦¨à¦¾à¦•à§à¦¤à¦•à¦°à¦£à§‡ à¦¤à§à¦°à§à¦Ÿà¦¿")
    if not fret_str and not cleaned_symbol_str: raise ValueError(f"{string_name}å¼¦: ä¸æ­£ãªTABã‚»ãƒ«å†…å®¹: '{cell_content}'ã€‚ãƒ•ãƒ¬ãƒƒãƒˆç•ªå·ã€'-'ã€ã¾ãŸã¯æ¼”å¥è¨˜å·ãŒå¿…è¦ã§ã™ã€‚ à¦¸à¦¨à¦¾à¦•à§à¦¤à¦•à¦°à¦£à§‡ à¦¤à§à¦°à§à¦Ÿà¦¿")
    return fret, (symbol_str if symbol_str else None)

def check_tab_format(lines):
    tab_lines = [line.strip() for line in lines if line.strip() and not line.strip().startswith('#')]
    if not tab_lines: return False, "å…¥åŠ›ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
    if len(tab_lines) % 4 != 0: return False, "è¡Œæ•°ãŒ4ã®å€æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚G,D,A,Eã®4è¡Œã‚»ãƒƒãƒˆã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
    for i in range(0, len(tab_lines), 4):
        block, block_num = tab_lines[i:i+4], (i // 4) + 1
        expected_prefixes = ['G|', 'D|', 'A|', 'E|']
        for j in range(4):
            if not block[j].startswith(expected_prefixes[j]): return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®{j+1}è¡Œç›®ãŒ'{expected_prefixes[j]}'ã§å§‹ã¾ã£ã¦ã„ã¾ã›ã‚“ã€‚"
        try: block_length = len(block[0].split('|', 1)[1])
        except IndexError: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®1è¡Œç›®ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä¸æ­£ã§ã™ã€‚"
        for j in range(1, 4):
            try:
                content = block[j].split('|', 1)[1]
                if len(content) != block_length: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}å†…ã§å„å¼¦ã®é•·ã•ãŒçµ±ä¸€ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
            except IndexError: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®{j+1}è¡Œç›®ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä¸æ­£ã§ã™ã€‚"
    return True, "OK"

def check_5tab_format(lines):
    tab_lines = [line.strip() for line in lines if line.strip() and not line.strip().startswith('#')]
    if not tab_lines: return False, "å…¥åŠ›ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"
    if len(tab_lines) % 5 != 0: return False, "è¡Œæ•°ãŒ5ã®å€æ•°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚G,D,A,E,Bã®5è¡Œã‚»ãƒƒãƒˆã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
    for i in range(0, len(tab_lines), 5):
        block, block_num = tab_lines[i:i+5], (i // 5) + 1
        prefixes1 = ['G|', 'D|', 'A|', 'E|', 'B|']
        prefixes2 = ['B|', 'E|', 'A|', 'D|', 'G|']
        check1 = all(block[j].startswith(prefixes1[j]) for j in range(5))
        check2 = all(block[j].startswith(prefixes2[j]) for j in range(5))
        if not (check1 or check2):
            return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®è¡Œã®æ¥é ­è¾ãŒ G,D,A,E,B ã¾ãŸã¯ B,E,A,D,G ã®é †ã«ãªã£ã¦ã„ã¾ã›ã‚“ã€‚"
        try: block_length = len(block[0].split('|', 1)[1])
        except IndexError: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®1è¡Œç›®ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä¸æ­£ã§ã™ã€‚"
        for j in range(1, 5):
            try:
                content = block[j].split('|', 1)[1]
                if len(content) != block_length: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}å†…ã§å„å¼¦ã®é•·ã•ãŒçµ±ä¸€ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
            except IndexError: return False, f"ãƒ–ãƒ­ãƒƒã‚¯{block_num}ã®{j+1}è¡Œç›®ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãŒä¸æ­£ã§ã™ã€‚"
    return True, "OK"

def parse_input(stitched_lines, num_strings):
    string_names = [l.split('|',1)[0] for l in stitched_lines]
    raw_strings = [line.split('|', 1)[1] for line in stitched_lines]
    max_len = max(len(s) for s in raw_strings) if raw_strings else 0
    raw_strings = [s.ljust(max_len, '-') for s in raw_strings]
    columns = list(zip(*raw_strings))
    parsed = [[] for _ in range(num_strings)]
    col_idx = 0
    while col_idx < len(columns):
        if columns[col_idx][0] == '|':
            for s_idx in range(num_strings): parsed[s_idx].append(('BAR', None))
            col_idx += 1
            continue
        width = 1
        if (col_idx + 1 < len(columns) and any(columns[col_idx][s_idx].isdigit() and columns[col_idx+1][s_idx].isdigit() for s_idx in range(num_strings))):
            width = 2
        block = columns[col_idx:col_idx+width]
        for s_idx in range(num_strings):
            cell = "".join(row[s_idx] for row in block)
            parsed[s_idx].append(extract_fret_and_symbol(cell, string_name=string_names[s_idx]))
        col_idx += width
    return parsed, len(parsed[0]) if parsed and parsed[0] else 0

def cost(cs, cf, ps, pf): return abs(cs-ps)*3 + abs(cf-pf)

def choose_string(midi_note, prev_s, prev_f, conversion_mode, open_string_midis):
    candidates = []
    for i in range(5):
        fret = midi_note - open_string_midis[i]
        if 0 <= fret <= 24:
            current_cost = cost(i, fret, prev_s, prev_f)
            if conversion_mode == 'b_string_optimized' and i == 0: current_cost -= 1000
            candidates.append((current_cost, i, fret))
    if not candidates:
        fallback = [(i, midi_note - m) for i,m in enumerate(open_string_midis) if midi_note - m >= 0]
        return min(fallback, key=lambda x: cost(x[0], x[1], prev_s, prev_f)) if fallback else (1,0)
    return min(candidates, key=lambda x: (x[0], x[1]))[1:]

def convert_4to5_tab(parsed_4str, length, conversion_mode, open_4_string_midis_gdae):
    output, prev_s, prev_f, last_string_mapping = [[] for _ in range(5)], 2, 0, {}
    e_midi_4str, a_midi_4str, d_midi_4str, g_midi_4str = open_4_string_midis_gdae[3], open_4_string_midis_gdae[2], open_4_string_midis_gdae[1], open_4_string_midis_gdae[0]
    open_5_string_midis_beadg = [e_midi_4str - 5, e_midi_4str, a_midi_4str, d_midi_4str, g_midi_4str]
    for pos in range(length):
        if parsed_4str[0][pos][0] == 'BAR':
            for _ in range(5): output[_].append('|')
            continue
        notes_at_pos, symbols_at_pos = [], []
        for i in range(4):
            fret, sym = parsed_4str[i][pos]
            if fret is not None:
                midi = open_4_string_midis_gdae[i] + fret
                notes_at_pos.append({'midi': midi, 'symbol': sym, 'original_string_idx': i})
            elif sym is not None: symbols_at_pos.append({'symbol': sym, 'original_string_idx': i})
        for s in range(5): output[s].append('-')
        if notes_at_pos:
            notes_at_pos.sort(key=lambda x: x['midi'])
            for note in notes_at_pos:
                s5, f5 = choose_string(note['midi'], prev_s, prev_f, conversion_mode, open_5_string_midis_beadg)
                prev_s, prev_f = s5, f5
                output[s5][-1], last_string_mapping[note['original_string_idx']] = (f5, note['symbol']), s5
        for sym_info in symbols_at_pos:
            original_idx, sym = sym_info['original_string_idx'], sym_info['symbol']
            target_s5 = last_string_mapping.get(original_idx)
            if target_s5 is not None:
                if output[target_s5][-1] == '-': output[target_s5][-1] = (None, sym)
            else:
                fallback_s5_map = {0:4, 1:3, 2:2, 3:1}
                fallback_s5 = fallback_s5_map.get(original_idx)
                if fallback_s5 is not None and output[fallback_s5][-1] == '-':
                    output[fallback_s5][-1] = (None, sym)
    return output, open_5_string_midis_beadg

def convert_5to4_tab(parsed_5str, length):
    output = [[] for _ in range(4)] # G, D, A, E
    open_5_string_midis_beadg = [59, 64, 69, 74, 79] # B, E, A, D, G
    open_4_string_midis_gdae = [79, 74, 69, 64] # G, D, A, E

    for pos in range(length):
        if parsed_5str[0][pos][0] == 'BAR':
            for i in range(4): output[i].append('|')
            continue
        for i in range(4): output[i].append('-')
        notes_at_pos = []
        for i in range(5): # B, E, A, D, G
            fret, sym = parsed_5str[i][pos]
            if fret is not None:
                midi = open_5_string_midis_beadg[i] + fret
                notes_at_pos.append({'midi': midi, 'symbol': sym})
        
        for note in notes_at_pos:
            midi, sym = note['midi'], note['symbol']
            candidates = []
            for s_idx in range(4): # G, D, A, E
                fret = midi - open_4_string_midis_gdae[s_idx]
                if 0 <= fret <= 24:
                    candidates.append((s_idx, fret))
            if candidates:
                best_s, best_f = min(candidates, key=lambda x: (x[1], x[0]))
                output[best_s][-1] = (best_f, sym)
    return output, open_4_string_midis_gdae

def format_output(output, open_string_midis):
    num_strings = len(output)
    if num_strings == 5:
        names = ['B','E','A','D','G']
        display_order_indices = [4, 3, 2, 1, 0] # G, D, A, E, B
    elif num_strings == 4:
        names = ['G','D','A','E']
        display_order_indices = [0, 1, 2, 3] # G, D, A, E
    else:
        return ""

    if not output or not any(output): return ""
    cols = len(output[0])
    widths = [1]*cols
    for ci in range(cols):
        if output[0][ci] == '|': continue
        max_w = 1
        for ri in range(num_strings):
            cell = output[ri][ci]
            txt_for_width = str(cell)
            if isinstance(cell, tuple):
                f, s = cell
                txt_for_width = (str(f) + s) if f is not None and s else (str(f) if f is not None else s or '-')
            max_w = max(max_w, len(txt_for_width))
        widths[ci] = max_w
    
    note_id_counter, formatted_cells = 0, [[] for _ in range(num_strings)]
    for ci in range(cols):
        w = widths[ci]
        for ri in range(num_strings):
            cell, txt = output[ri][ci], ""
            if cell == '|': txt = '|'
            elif isinstance(cell, tuple):
                f,s = cell
                span_content = (str(f) if f is not None else '') + (s if s is not None else '')
                dashes = '-' * max(0, w - len(span_content))
                if f is not None:
                    midi_note = open_string_midis[ri] + f
                    txt = f'<span class="fret-note" data-note-id="{note_id_counter}" data-midi-note="{midi_note}" data-string-index="{ri}">{span_content}{dashes}</span>'
                    note_id_counter += 1
                else: txt = f'{span_content}{dashes}'
            else: txt = str(cell).ljust(w, '-')
            formatted_cells[ri].append(txt)

    lines = {i: "".join(formatted_cells[i]) for i in range(num_strings)}
    string_names_ordered = [names[i] for i in display_order_indices]
    final_lines = []
    full_content = [f"{string_names_ordered[string_idx]}|{lines[display_order_indices[string_idx]]}" for string_idx in range(num_strings)]
    
    measures = [line.split('|')[1:-1] for line in full_content]
    if not measures or not measures[0]: return "\n".join(full_content)

    num_measures = len(measures[0])
    for i in range(0, num_measures, 4):
        end = min(i + 4, num_measures)
        for string_idx, name in enumerate(string_names_ordered):
            line_part = '|'.join(measures[string_idx][i:end])
            final_lines.append(f"{name}|{line_part}|")
        if end < num_measures: final_lines.append("")
    return "\n".join(final_lines)

def get_template(evt):
    template = '''# 4å¼¦TABãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
# ãƒ»G,D,A,E ã®4è¡Œ
# ãƒ»ãƒ•ãƒ¬ãƒƒãƒˆ0-24ã€ç©ºæ¬„ã¯"-"
G|--------------------------------|
D|--------------------------------|
A|--------------------------------|
E|--------------------------------|
'''
    blob = Blob.new([template], {"type":"text/plain"})
    url = URL.createObjectURL(blob)
    a = document.createElement("a"); a.href, a.download = url, "4string_template.txt"
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url)
    document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['template_download_success']
    document.getElementById("status_message").style.color = "#4CAF50"

def run_format_check(evt):
    status_msg = document.getElementById("status_message")
    direction = document.querySelector('input[name="conversion_direction"]:checked').value
    try:
        txt = document.getElementById("input_tab").value
        lines = [l.strip() for l in txt.splitlines() if l.strip()]
        if direction == '4to5':
            ok, msg = check_tab_format(lines)
            if not ok: raise ValueError(msg)
        else: # 5to4
            ok, msg = check_5tab_format(lines)
            if not ok: raise ValueError(msg)
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_format_ok']
        status_msg.style.color = "#4CAF50"
    except Exception as e:
        error_key = 'status_check_5_string_format_error' if direction == '5to4' else 'status_format_error'
        status_msg.textContent = LANGUAGES[CURRENT_LANG][error_key].format(error=str(e))
        status_msg.style.color = "#f44336"

def on_convert(evt):
    global CONVERTED_NOTES_DATA
    status_msg, output_area = document.getElementById("status_message"), document.getElementById("output_tab")
    direction = document.querySelector('input[name="conversion_direction"]:checked').value
    try:
        txt = document.getElementById("input_tab").value
        lines = [l.strip() for l in txt.splitlines() if l.strip()]
        
        if direction == '4to5':
            ok, msg = check_tab_format(lines)
            if not ok: raise ValueError(msg)
            
            string_order = ['G', 'D', 'A', 'E']
            stitched_parts = {s: [] for s in string_order}
            for i, line in enumerate(lines):
                key = string_order[i % 4]
                content = line.split('|', 1)[1]
                stitched_parts[key].append(content)
            stitched_lines = [f"{s}|{''.join(stitched_parts[s])}" for s in string_order]
            
            tuning_dict = document.defaultView.getCustomTuning().to_py()
            open_4_gdae = [note_to_midi(tuning_dict[s]['note'], tuning_dict[s]['octave']) for s in ['g','d','a','e']]
            
            selected_mode = document.querySelector('input[name="conversion_mode"]:checked').value
            parsed, length = parse_input(stitched_lines, 4)
            converted_beadg, open_5_beadg = convert_4to5_tab(parsed, length, selected_mode, open_4_gdae)
            result = format_output(converted_beadg, open_5_beadg)
            
            output_area.innerHTML = result
            status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_convert_success']
            status_msg.style.color = "#4CAF50"
            
            plain_text_output = document.getElementById("output_tab").textContent
            open_5_gdaeb = [open_5_beadg[4], open_5_beadg[3], open_5_beadg[2], open_5_beadg[1], open_5_beadg[0]]
            CONVERTED_NOTES_DATA = parse_tab_for_playback(plain_text_output, 5, open_string_midis=open_5_gdaeb)

        elif direction == '5to4':
            ok, msg = check_5tab_format(lines)
            if not ok: raise ValueError(msg)
            
            tab_lines_only = [l for l in lines if l.strip()]
            is_g_first = any(line.strip().startswith('G|') for line in tab_lines_only)
            string_order_in_file = ['G', 'D', 'A', 'E', 'B'] if is_g_first else ['B', 'E', 'A', 'D', 'G']
            
            stitched_parts = {s: [] for s in string_order_in_file}
            for i, line in enumerate(tab_lines_only):
                key = string_order_in_file[i % 5]
                content = line.split('|', 1)[1]
                stitched_parts[key].append(content)

            canonical_order_for_parsing = ['B', 'E', 'A', 'D', 'G']
            stitched_lines = [f"{s}|{''.join(stitched_parts[s])}" for s in canonical_order_for_parsing]
            
            parsed, length = parse_input(stitched_lines, 5)
            converted_gdae, open_4_gdae = convert_5to4_tab(parsed, length)
            
            result = format_output(converted_gdae, open_4_gdae)

            output_area.innerHTML = result
            status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_convert_5to4_success']
            status_msg.style.color = "#4CAF50"

            plain_text_output = document.getElementById("output_tab").textContent
            CONVERTED_NOTES_DATA = parse_tab_for_playback(plain_text_output, 4, open_string_midis=open_4_gdae)

    except Exception as e:
        output_area.textContent, CONVERTED_NOTES_DATA = "", None
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_convert_error'].format(error=str(e))
        status_msg.style.color = "#f44336"


def on_download(evt):
    out, status_msg = document.getElementById("output_tab").textContent, document.getElementById("status_message")
    if not out.strip():
        status_msg.textContent, status_msg.style.color = LANGUAGES[CURRENT_LANG]['status_download_empty'], "#f44336"
        return
    blob = Blob.new([out], {"type":"text/plain"})
    url = URL.createObjectURL(blob)
    a = document.createElement("a"); a.href, a.download = url, "bass_tab_result.txt"
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url)
    status_msg.textContent, status_msg.style.color = LANGUAGES[CURRENT_LANG]['status_download_success'], "#4CAF50"

def parse_tab_for_playback(tab_string, num_strings, tuning_data=None, open_string_midis=None):
    lines = [l.strip() for l in tab_string.splitlines() if l.strip() and not l.strip().startswith('#')]
    if not lines or len(lines) % num_strings != 0: return []
    string_order = ['G', 'D', 'A', 'E'] if num_strings == 4 else ['G', 'D', 'A', 'E', 'B']
    parts = {s: [] for s in string_order}
    for line in lines:
        if line and line[0] in parts: parts[line[0]].append(line.split('|', 1)[1])
    stitched_content = {s: "".join(parts[s]) for s in string_order}
    
    base_midi_notes = []
    if open_string_midis:
        base_midi_notes = open_string_midis
    elif num_strings == 4:
        base_midi_notes = [79, 74, 69, 64] # G, D, A, E
    elif num_strings == 5:
        base_midi_notes = [79, 74, 69, 64, 59] # G, D, A, E, B

    notes_data, max_len = [], max(len(v) for v in stitched_content.values()) if stitched_content and any(stitched_content.values()) else 0
    tick_per_unit, musical_pos, char_idx, note_id_counter = 120, 0, 0, 0
    while char_idx < max_len:
        notes_in_col, width = [], 1
        w_check = 1
        for s_name in string_order:
            content = stitched_content.get(s_name, '')
            if char_idx < len(content) and content[char_idx].isdigit():
                f_str, t_idx = "", char_idx
                while t_idx < len(content) and content[t_idx].isdigit(): f_str, t_idx = f_str + content[t_idx], t_idx + 1
                w_check = max(w_check, len(f_str))
        width = w_check
        
        s_map_4_string = {0: 3, 1: 2, 2: 1, 3: 0} # GDAE -> 3210 for EADG
        s_map_5_string = {0: 4, 1: 3, 2: 2, 3: 1, 4: 0} # GDAEB -> 43210 for BEADG
        s_map = s_map_5_string if num_strings == 5 else s_map_4_string

        for s_idx, s_name in enumerate(string_order):
            content = stitched_content.get(s_name, '')
            if char_idx < len(content) and content[char_idx].isdigit():
                if char_idx == 0 or (char_idx > 0 and not content[char_idx-1].isdigit()):
                    f_str, t_idx = "", char_idx
                    while t_idx < len(content) and content[t_idx].isdigit(): f_str, t_idx = f_str + content[t_idx], t_idx + 1
                    if base_midi_notes and s_idx < len(base_midi_notes):
                        midi = base_midi_notes[s_idx] + int(f_str)
                        internal_s_idx = s_map.get(s_idx, s_idx)
                        notes_in_col.append({'midi': midi, 'string_idx': internal_s_idx, 'note_id': note_id_counter})
                        note_id_counter += 1
        if notes_in_col: notes_data.append({'tick': musical_pos * tick_per_unit, 'notes': notes_in_col, 'durationTicks': tick_per_unit})
        char_idx, musical_pos = char_idx + width, musical_pos + 1
    return notes_data

def prepare_and_play(evt):
    tab_type = 'input' if 'input' in evt.target.id else 'output'
    direction = document.querySelector('input[name="conversion_direction"]:checked').value
    
    num_strings_input = 5 if direction == '5to4' else 4

    if tab_type == 'input':
        tab_string = document.getElementById("input_tab").value
        notes = parse_tab_for_playback(tab_string, num_strings_input, document.defaultView.getCustomTuning())
    else: # output
        if not CONVERTED_NOTES_DATA:
            document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_download_empty']
            document.getElementById("status_message").style.color = "#f44336"
            return
        notes = CONVERTED_NOTES_DATA
    
    if not notes:
        document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_no_notes_to_play']
        document.getElementById("status_message").style.color = "#f44336"
        return
    document.defaultView.playAudioFromData(json.dumps(notes))

def prepare_and_export_midi(evt):
    if not CONVERTED_NOTES_DATA:
        document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_no_notes_to_export']
        document.getElementById("status_message").style.color = "#f44336"
        return
    notes = CONVERTED_NOTES_DATA
    document.defaultView.exportMidiFromData(json.dumps(notes))
    document.getElementById("status_message").textContent = LANGUAGES[CURRENT_LANG]['status_midi_exported']
    document.getElementById("status_message").style.color = "#4CAF50"

def parse_chord(chord_str):
    chord_str = chord_str.strip()
    if not chord_str: return None, None, None
    root_note, rest = chord_str[0], chord_str[1:]
    if len(chord_str) > 1 and chord_str[1] in ('#', 'b'):
        root_note, rest = chord_str[:2], chord_str[2:]
    
    if '/' in rest:
        quality, bass_note = rest.split('/')
        return root_note, quality.strip(), bass_note.strip()
    else:
        return root_note, rest.strip(), None

CHORD_INTERVALS = {
    # Major
    '': [0, 4, 7], 'maj': [0, 4, 7], 'M': [0, 4, 7],
    'maj7': [0, 4, 7, 11], 'M7': [0, 4, 7, 11],
    # Minor
    'm': [0, 3, 7], 'min': [0, 3, 7],
    'm7': [0, 3, 7, 10], 'min7': [0, 3, 7, 10],
    # Dominant
    '7': [0, 4, 7, 10], 'dom7': [0, 4, 7, 10],
    # Diminished
    'dim': [0, 3, 6], 'dim7': [0, 3, 6, 9],
    # Augmented
    'aug': [0, 4, 8], '+': [0, 4, 8],
    # Half-diminished
    'm7b5': [0, 3, 6, 10],
}

def generate_bassline(chords_str, genre, tuning_info_py):
    lines = [l.strip() for l in chords_str.splitlines() if l.strip()]
    chords_in_measures = []
    for line in lines:
        chords_in_measures.extend(line.split('|'))

    parsed_chords = []
    for measure in chords_in_measures:
        parts = [c.strip() for c in measure.split() if c.strip()]
        if not parts: parsed_chords.append(None)
        else: parsed_chords.append(parts)

    open_string_midis = {
        'E': note_to_midi(tuning_info_py['e']['note'], tuning_info_py['e']['octave']),
        'A': note_to_midi(tuning_info_py['a']['note'], tuning_info_py['a']['octave']),
        'D': note_to_midi(tuning_info_py['d']['note'], tuning_info_py['d']['octave']),
        'G': note_to_midi(tuning_info_py['g']['note'], tuning_info_py['g']['octave'])
    }
    string_order_for_find = ['G', 'D', 'A', 'E']

    memo_find_fret = {}
    def find_fret(midi_note):
        if midi_note in memo_find_fret: return memo_find_fret[midi_note]
        best_option = (100, -1, -1)
        for i, s_name in enumerate(string_order_for_find):
            open_midi = open_string_midis[s_name]
            if midi_note >= open_midi:
                fret = midi_note - open_midi
                if fret <= 24:
                    cost = i * 2 + fret
                    if fret == 0: cost -= 2
                    if cost < best_option[0]:
                        best_option = (cost, i, fret)
        memo_find_fret[midi_note] = best_option[1:]
        return best_option[1:]

    tab_measures = {'G': [], 'D': [], 'A': [], 'E': []}

    for i, measure_chords in enumerate(parsed_chords):
        measure_len = 8
        g_m, d_m, a_m, e_m = ['-']*measure_len, ['-']*measure_len, ['-']*measure_len, ['-']*measure_len
        
        if not measure_chords:
            tab_measures['G'].append('-' * measure_len)
            tab_measures['D'].append('-' * measure_len)
            tab_measures['A'].append('-' * measure_len)
            tab_measures['E'].append('-' * measure_len)
            continue

        beats_per_chord = measure_len // len(measure_chords)
        current_pos = 0

        for j, chord_str in enumerate(measure_chords):
            root_name, quality, bass_note = parse_chord(chord_str)
            if root_name is None: continue

            target_note_name = bass_note if bass_note else root_name
            root_midi = -1
            for octave in range(1, 4):
                midi = note_to_midi(target_note_name.upper(), octave)
                if midi >= open_string_midis['E']: 
                    root_midi = midi
                    break
            if root_midi == -1: root_midi = note_to_midi(target_note_name.upper(), 2)

            notes_to_play = []
            if genre == 'rock':
                notes_to_play.append(root_midi)
            elif genre == 'funk':
                notes_to_play.extend([root_midi, root_midi])
            elif genre == 'jazz':
                intervals = CHORD_INTERVALS.get(quality, [0, 4, 7])
                chord_tones = [root_midi + interval for interval in intervals]
                
                # Simple walking bass: 1, 3, 5, approach
                walk = [root_midi, chord_tones[1] if len(chord_tones) > 1 else root_midi + 4, chord_tones[2] if len(chord_tones) > 2 else root_midi + 7]
                
                # Find next chord's root for approach note
                next_root_midi = root_midi
                if j + 1 < len(measure_chords):
                    next_root_name, _, _ = parse_chord(measure_chords[j+1])
                    if next_root_name: next_root_midi = note_to_midi(next_root_name.upper(), 2)
                elif i + 1 < len(parsed_chords) and parsed_chords[i+1]:
                    next_root_name, _, _ = parse_chord(parsed_chords[i+1][0])
                    if next_root_name: next_root_midi = note_to_midi(next_root_name.upper(), 2)

                approach_note = next_root_midi - 1 # Chromatic approach from below
                walk.append(approach_note)
                notes_to_play = walk

            beat_pos = 0
            for note_midi in notes_to_play:
                s_idx, fret = find_fret(note_midi)
                if s_idx != -1:
                    fret_str = str(fret)
                    note_placement_pos = current_pos + beat_pos
                    if note_placement_pos < measure_len:
                        if s_idx == 0: g_m[note_placement_pos] = fret_str
                        elif s_idx == 1: d_m[note_placement_pos] = fret_str
                        elif s_idx == 2: a_m[note_placement_pos] = fret_str
                        elif s_idx == 3: e_m[note_placement_pos] = fret_str
                
                if genre == 'funk': beat_pos += 3
                else: beat_pos += 2 # Quarter notes for rock/jazz

            current_pos += beats_per_chord

        tab_measures['G'].append("".join(g_m))
        tab_measures['D'].append("".join(d_m))
        tab_measures['A'].append("".join(a_m))
        tab_measures['E'].append("".join(e_m))

    output_lines = []
    num_measures = len(tab_measures['G'])
    for i in range(0, num_measures, 4):
        end = min(i + 4, num_measures)
        output_lines.append(f"G|{'|'.join(tab_measures['G'][i:end])}|")
        output_lines.append(f"D|{'|'.join(tab_measures['D'][i:end])}|")
        output_lines.append(f"A|{'|'.join(tab_measures['A'][i:end])}|")
        output_lines.append(f"E|{'|'.join(tab_measures['E'][i:end])}|")
        if end < num_measures: output_lines.append("")

    return "\n".join(output_lines)

def on_generate_bassline(evt):
    status_msg = document.getElementById("status_message")
    try:
        chords_str = document.getElementById("chord_input").value
        genre = document.getElementById("genre_select").value
        tuning_info = document.defaultView.getCustomTuning()
        tuning_info_py = tuning_info.to_py()

        bassline_tab = generate_bassline(chords_str, genre, tuning_info_py)
        document.getElementById("input_tab").value = bassline_tab
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_bassline_generated']
        status_msg.style.color = "#4CAF50"
    except Exception as e:
        status_msg.textContent = LANGUAGES[CURRENT_LANG]['status_bassline_error'].format(error=str(e))
        status_msg.style.color = "#f44336"

def setup_event_listeners():
    document.getElementById("get_template_btn").addEventListener("click", create_proxy(get_template))
    document.getElementById("format_check_btn").addEventListener("click", create_proxy(run_format_check))
    document.getElementById("convert_btn").addEventListener("click", create_proxy(on_convert))
    document.getElementById("download_btn").addEventListener("click", create_proxy(on_download))
    document.getElementById("lang-ja").addEventListener("click", create_proxy(lambda e: set_language('ja')))
    document.getElementById("lang-en").addEventListener("click", create_proxy(lambda e: set_language('en')))
    document.getElementById("play_input_btn").addEventListener("click", create_proxy(prepare_and_play))
    document.getElementById("play_output_btn").addEventListener("click", create_proxy(prepare_and_play))
    document.getElementById("export_midi_btn").addEventListener("click", create_proxy(prepare_and_export_midi))
    document.getElementById("generate_bassline_btn").addEventListener("click", create_proxy(on_generate_bassline))

setup_event_listeners()
set_language('ja')
</py-script>

<script src="https://cdn.jsdelivr.net/npm/midi-writer-js@2.1.4/dist/midi-writer-js.min.js"></script>
<script>
    let audioContext; 
    let currentPlayback = { stop: () => {} }; 

    function getNoteFrequency(midiNote) {
        return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    async function playAudioFromData(notesJson) {
        if (currentPlayback && typeof currentPlayback.stop === 'function') {
            currentPlayback.stop();
        }

        const notesData = JSON.parse(notesJson);
        if (notesData.length === 0) return;

        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const scheduledOscillators = [];
        const highlightedElements = new Set();

        const bpm = document.getElementById('bpm_input').value;
        const ticksPerBeat = 480; 
        const secondsPerTick = 60 / (bpm * ticksPerBeat); 
        const startTime = audioContext.currentTime + 0.1;
        const metronomeEnabled = document.getElementById('metronome_enabled').checked;

        // Metronome logic
        if (metronomeEnabled) {
            const beats = (notesData.length > 0 ? (notesData[notesData.length - 1].tick / ticksPerBeat) : 0) + 4; // Add some extra beats
            for (let beat = 0; beat < beats; beat++) {
                const time = startTime + beat * (60 / bpm);
                const clickOsc = audioContext.createOscillator();
                clickOsc.type = 'sine';
                clickOsc.frequency.setValueAtTime(1000, time);
                const clickGain = audioContext.createGain();
                clickGain.gain.setValueAtTime(1, time);
                clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                clickOsc.connect(clickGain);
                clickGain.connect(audioContext.destination);
                clickOsc.start(time);
                clickOsc.stop(time + 0.05);
                scheduledOscillators.push(clickOsc);
            }
        }

        notesData.forEach(event => {
            const time = startTime + event.tick * secondsPerTick;
            const duration = event.durationTicks * secondsPerTick;
            
            let noteDelay = 0;
            const staggerDelay = 0.05;

            event.notes.sort((a, b) => a.string_idx - b.string_idx);

            event.notes.forEach((noteInfo) => {
                const currentNoteTime = time + noteDelay;
                const frequency = getNoteFrequency(noteInfo.midi);

                // --- Fret Highlighting Logic (MODIFIED) ---
                const fretElement = document.querySelector(
                    `#output_tab span.fret-note[data-note-id="${noteInfo.note_id}"]`
                );

                if (fretElement) {
                    const element = fretElement;
                    const highlightStartTime = Math.max(currentNoteTime, audioContext.currentTime);
                    const highlightEndTime = Math.max(currentNoteTime + duration, audioContext.currentTime);

                    if (highlightStartTime >= audioContext.currentTime) {
                        setTimeout(() => {
                            element.classList.add('playing-fret');
                            highlightedElements.add(element);
                        }, (highlightStartTime - audioContext.currentTime) * 1000);
                    } else {
                        element.classList.add('playing-fret');
                        highlightedElements.add(element);
                    }

                    if (highlightEndTime >= audioContext.currentTime) {
                        setTimeout(() => {
                            element.classList.remove('playing-fret');
                            highlightedElements.delete(element);
                        }, (highlightEndTime - audioContext.currentTime) * 1000);
                    }
                }

                const osc1 = audioContext.createOscillator();
                osc1.type = 'sawtooth'; 
                osc1.frequency.setValueAtTime(frequency, currentNoteTime);

                const osc2 = audioContext.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(frequency / 2, currentNoteTime);

                const gainNode = audioContext.createGain();
                const osc1Gain = audioContext.createGain();
                osc1Gain.gain.setValueAtTime(0.7, currentNoteTime);
                osc1.connect(osc1Gain);
                osc1Gain.connect(gainNode);

                const osc2Gain = audioContext.createGain();
                osc2Gain.gain.setValueAtTime(0.3, currentNoteTime);
                osc2.connect(osc2Gain);
                osc2Gain.connect(gainNode);

                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(1000, currentNoteTime);
                filter.Q.setValueAtTime(1, currentNoteTime);
                gainNode.connect(filter);
                filter.connect(audioContext.destination);

                gainNode.gain.setValueAtTime(0, currentNoteTime);
                gainNode.gain.linearRampToValueAtTime(0.8, currentNoteTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.4, currentNoteTime + 0.1);
                gainNode.gain.setValueAtTime(0.4, currentNoteTime + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, currentNoteTime + duration);

                osc1.start(currentNoteTime);
                osc2.start(currentNoteTime);
                osc1.stop(currentNoteTime + duration + 0.1);
                osc2.stop(currentNoteTime + duration + 0.1); 

                scheduledOscillators.push(osc1, osc2);
                noteDelay += staggerDelay;
            });
        });

        currentPlayback = {
            stop: () => {
                if (audioContext && audioContext.state !== 'closed') {
                    scheduledOscillators.forEach(osc => { try { osc.stop(0); } catch (e) {} });
                    highlightedElements.forEach(element => {
                        element.classList.remove('playing-fret');
                    });
                    highlightedElements.clear();
                    audioContext.close().then(() => { audioContext = null; });
                }
            }
        };
    }

    function exportMidiFromData(notesJson) {
        const notesData = JSON.parse(notesJson);
        if (notesData.length === 0) return;

        const bpm = document.getElementById('bpm_input').value;
        const writer = new MidiWriter.Writer();
        const track = new MidiWriter.Track();
        track.setTempo(bpm);
        track.addTrackName('Bass');
        track.addInstrumentName('Electric Bass (finger)');
        
        notesData.forEach(event => {
            track.addEvent(new MidiWriter.NoteEvent({
                pitch: event.notes.map(n => n.midi),
                tick: event.tick,
                duration: `T${event.durationTicks}`
            }));
        });

        writer.addTrack(track);
        const a = document.createElement('a');
        a.href = writer.dataUri();
        a.download = 'bass_tab_export.mid';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const stringConfigs = [
        { id: 'g', label: 'G-String', defaultNote: 'G', defaultOctave: 2 },
        { id: 'd', label: 'D-String', defaultNote: 'D', defaultOctave: 2 },
        { id: 'a', label: 'A-String', defaultNote: 'A', defaultOctave: 1 },
        { id: 'e', label: 'E-String', defaultNote: 'E', defaultOctave: 1 },
    ];

    function setupCustomTuningUI() {
        const container = document.getElementById('custom-tuning-area');
        container.innerHTML = '';

        stringConfigs.forEach(s => {
            const stringGroup = document.createElement('div');
            stringGroup.className = 'tuning-string-group';

            const labelSpan = document.createElement('span');
            labelSpan.className = 'string-label';
            labelSpan.textContent = s.label;
            stringGroup.appendChild(labelSpan);

            const noteSelect = document.createElement('select');
            noteSelect.className = 'note-select';
            noteSelect.id = `${s.id}-note`;
            noteNames.forEach(note => {
                const option = document.createElement('option');
                option.value = note;
                option.textContent = note;
                noteSelect.appendChild(option);
            });
            stringGroup.appendChild(noteSelect);

            const octaveSelect = document.createElement('select');
            octaveSelect.className = 'octave-select';
            octaveSelect.id = `${s.id}-octave`;
            for (let i = 0; i <= 5; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                octaveSelect.appendChild(option);
            }
            stringGroup.appendChild(octaveSelect);

            container.appendChild(stringGroup);
        });

        setTuningPreset('standard');

        document.getElementById('tuning-presets').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const preset = e.target.dataset.tuning;
                if (preset) {
                    setTuningPreset(preset);
                } 
            } 
        });
    }

    function setTuningPreset(preset) {
        let tunings;
        switch (preset) {
            case 'half_down':
                tunings = { g: ['F#', 2], d: ['C#', 2], a: ['G#', 1], e: ['D#', 1] };
                break;
            case 'drop_d':
                tunings = { g: ['G', 2], d: ['D', 2], a: ['A', 1], e: ['D', 1] };
                break;
            case 'standard':
            default:
                tunings = { g: ['G', 2], d: ['D', 2], a: ['A', 1], e: ['E', 1] };
                break;
        }
        for (const strId in tunings) {
            document.getElementById(`${strId}-note`).value = tunings[strId][0];
            document.getElementById(`${strId}-octave`).value = tunings[strId][1];
        }
        
        const buttons = document.querySelectorAll('#tuning-presets button');
        buttons.forEach(btn => {
            if (btn.dataset.tuning === preset) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }
    
    function getCustomTuning() {
        const tuning = {};
        stringConfigs.forEach(s => {
            const note = document.getElementById(`${s.id}-note`).value;
            const octave = document.getElementById(`${s.id}-octave`).value;
            tuning[s.id] = {note, octave: parseInt(octave)};
        });
        return tuning;
    }

    window.getCustomTuning = getCustomTuning;

    document.addEventListener('DOMContentLoaded', () => {
        setupCustomTuningUI();
        
        // Event listener for conversion direction
        document.querySelectorAll('input[name="conversion_direction"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const direction = e.target.value;
                const convertBtn = document.getElementById('convert_btn');
                const inputTab = document.getElementById('input_tab');
                const fourToFiveOptions = document.getElementById('4to5_options');
                const pyodideReady = !!window.pyodide;
                const lang = pyodideReady ? pyodide.globals.get('CURRENT_LANG') : 'ja';
                const translations = pyodideReady ? pyodide.globals.get('LANGUAGES').toJs().get(lang) : {};

                if (direction === '5to4') {
                    fourToFiveOptions.style.display = 'none';
                    convertBtn.setAttribute('data-lang-key', 'btn_convert_to_4_string');
                    convertBtn.textContent = translations.btn_convert_to_4_string || "4å¼¦TABã«å¤‰æ›";
                    inputTab.setAttribute('data-lang-key-placeholder', 'placeholder_text_5_string');
                    inputTab.placeholder = translations.placeholder_text_5_string || "ã“ã“ã«5å¼¦TABï¼ˆB|... E|... A|... D|... G|...ï¼‰ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„";
                } else { // 4to5
                    fourToFiveOptions.style.display = 'block';
                    convertBtn.setAttribute('data-lang-key', 'btn_convert_to_5_string');
                    convertBtn.textContent = translations.btn_convert_to_5_string || "5å¼¦TABã«å¤‰æ›";
                    inputTab.setAttribute('data-lang-key-placeholder', 'placeholder_text_4_string');
                    inputTab.placeholder = translations.placeholder_text_4_string || "ã“ã“ã«4å¼¦TABï¼ˆG|... D|... A|... E|...ï¼‰ã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„";
                }
            });
        });
    });
</script>


<script>
    document.addEventListener('DOMContentLoaded', () => {
        const downloadPdfBtn = document.getElementById('download_pdf_btn');
        if (downloadPdfBtn) {
            downloadPdfBtn.addEventListener('click', async () => {
                const statusMessage = document.getElementById('status_message');
                statusMessage.textContent = 'PDFã‚’ç”Ÿæˆä¸­...';
                statusMessage.style.color = '#007acc';

                try {
                    const rawTabContent = document.getElementById('output_tab').textContent;
                    if (!rawTabContent.trim()) {
                        throw new Error('å¤‰æ›çµæœãŒã‚ã‚Šã¾ã›ã‚“ã€‚å…ˆã«TABã‚’å¤‰æ›ã—ã¦ãã ã•ã„ã€‚');
                    }

                    const lines = rawTabContent.split('\n').map(line => line.trim()).filter(line => line.length > 0 && !line.startsWith('#'));
                    
                    let is5String = lines.some(line => line.startsWith('B|'));
                    const numStrings = is5String ? 5 : 4;
                    const stringPrefixes = is5String ? ['G|', 'D|', 'A|', 'E|', 'B|'] : ['G|', 'D|', 'A|', 'E|'];
                    const stringMap = new Map(stringPrefixes.map((p, i) => [p, i]));

                    const allMeasures = Array.from({ length: numStrings }, () => []);

                    for (const line of lines) {
                        const prefix = stringPrefixes.find(p => line.startsWith(p));
                        if (prefix) {
                            const stringIndex = stringMap.get(prefix);
                            const content = line.substring(line.indexOf('|') + 1);
                            const measures = content.split('|').filter(m => m.length > 0);
                            measures.forEach(m => allMeasures[stringIndex].push(m));
                        }
                    }

                    const formattedTabLines = [];
                    const maxTotalMeasures = Math.max(0, ...allMeasures.map(arr => arr.length));
                    const maxMeasuresPerBlock = 4;

                    for (let i = 0; i < maxTotalMeasures; i += maxMeasuresPerBlock) {
                        const blockEnd = Math.min(i + maxMeasuresPerBlock, maxTotalMeasures);
                        const measureWidths = [];
                        for (let j = i; j < blockEnd; j++) {
                            let maxWidth = 0;
                            for (let s = 0; s < numStrings; s++) {
                                if (j < allMeasures[s].length) {
                                    maxWidth = Math.max(maxWidth, allMeasures[s][j].length);
                                }
                            }
                            measureWidths.push(maxWidth);
                        }

                        for (let s = 0; s < numStrings; s++) {
                            let line = stringPrefixes[s];
                            for (let j = i; j < blockEnd; j++) {
                                const measureIndexInBlock = j - i;
                                const width = measureWidths[measureIndexInBlock];
                                const measure = j < allMeasures[s].length ? allMeasures[s][j] : '';
                                line += measure.padEnd(width, '-') + '|';
                            }
                            formattedTabLines.push(line);
                        }
                        if (blockEnd < maxTotalMeasures) {
                            formattedTabLines.push('');
                        }
                    }

                    const formattedTab = formattedTabLines.join('\n');
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ unit: 'pt', format: 'a4' });

                    doc.setFont('courier');
                    doc.setFontSize(8);

                    const textLines = doc.splitTextToSize(formattedTab, doc.internal.pageSize.getWidth() - 20);
                    let y = 20;
                    const lineHeight = 10;

                    textLines.forEach((line, index) => {
                        if (y + lineHeight > doc.internal.pageSize.getHeight() - 20) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(line, 10, y);
                        y += lineHeight;
                    });

                    doc.save('bass_tab_converted.pdf');
                    statusMessage.textContent = 'PDFã‚’ç”Ÿæˆã—ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚';
                    statusMessage.style.color = '#4CAF50';

                } catch (error) {
                    console.error('PDFç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                    statusMessage.textContent = `PDFç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
                    statusMessage.style.color = '#f44336';
                }
            });
        }
    });
</script>
